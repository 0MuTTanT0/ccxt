<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use \ccxtpro\ClientTrait; // websocket functionality
use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\NotSupported;

class binance extends \ccxt\binance {

    use ClientTrait;

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'has' => array(
                'watchOrderBook' => true,
                'watchOHLCV' => true,
                'watchTrades' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://stream.binance.com:9443/ws',
                    // 'ws' => 'wss://echo.websocket.org/',
                    // 'ws' => 'ws://127.0.0.1:8080',
                ),
            ),
            'options' => array(
                'marketsByLowerCaseId' => array(),
            ),
        ));
    }

    public function load_markets ($reload = false, $params = array ()) {
        $markets = parent::load_markets($reload, $params);
        $marketsByLowercaseId = $this->safe_value($this->options, 'marketsByLowercaseId');
        if (($marketsByLowercaseId === null) || $reload) {
            $marketsByLowercaseId = array();
            for ($i = 0; $i < count($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $lowercaseId = strtolower($this->markets[$symbol]['id']);
                $this->markets[$symbol]['lowercaseId'] = $lowercaseId;
                $marketsByLowercaseId[$lowercaseId] = $this->markets[$symbol];
            }
            $this->options['marketsByLowercaseId'] = $marketsByLowercaseId;
        }
        return $markets;
    }

    public function watch_trades ($symbol) {
        //     $this->load_markets();
        //     $market = $this->market ($symbol);
        //     $url = $this->urls['api']['ws'] . strtolower($market['id']) . '@trade';
        //     return $this->WsTradesMessage ($url, $url);
        throw new NotSupported($this->id . ' watchTrades not implemented yet');
    }

    public function handle_trades ($response) {
        //     $parsed = $this->parse_trade($response);
        //     $parsed['symbol'] = $this->parseSymbol ($response);
        //     return $parsed;
        throw new NotSupported($this->id . ' handleTrades not implemented yet');
    }

    public function watch_ohlcv ($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        //     $this->load_markets();
        //     $interval = $this->timeframes[$timeframe];
        //     $market = $this->market ($symbol);
        //     $url = $this->urls['api']['ws'] . strtolower($market['id']) . '@kline_' . $interval;
        //     return $this->WsOHLCVMessage ($url, $url);
        throw new NotSupported($this->id . ' watchOHLCV not implemented yet');
    }

    public function handle_ohlcv ($ohlcv) {
        //     $data = $ohlcv['k'];
        //     $timestamp = $this->safe_integer($data, 'T');
        //     $open = $this->safe_float($data, 'o');
        //     $high = $this->safe_float($data, 'h');
        //     $close = $this->safe_float($data, 'l');
        //     $low = $this->safe_float($data, 'c');
        //     $volume = $this->safe_float($data, 'v');
        //     return [$timestamp, $open, $high, $close, $low, $volume];
        throw new NotSupported($this->id . ' handleOHLCV not implemented yet ' . $this->json ($ohlcv));
    }

    public function watch_order_book ($symbol, $limit = null, $params = array ()) {
        // for 1000ms => <$symbol>@depth<levels>
        // OR
        // for 100ms => <$symbol>@depth<levels>@100ms
        // valid <levels> are 5, 10, or 20
        if ($limit !== null) {
            if (($limit !== 25) && ($limit !== 100)) {
                throw new ExchangeError($this->id . ' watchOrderBook $limit argument must be null, 5, 10 or 20');
            }
        }
        $this->load_markets();
        $market = $this->market ($symbol);
        // this should be executed much later
        // $orderbook = $this->fetch_order_book($symbol, $limit, $params);
        // $request = array();
        $name = 'depth';
        $messageHash = $market['lowercaseId'] . '@' . $name;
        $url = $this->urls['api']['ws']; // . '/' . $messageHash;
        $requestId = $this->nonce ();
        $request = array(
            'method' => 'SUBSCRIBE',
            'params' => array(
                $messageHash,
            ),
            'id' => $requestId,
        );
        return $this->watch ($url, $messageHash, array_merge($request, $params), $messageHash);
        // $this->onetwo = future;
        // $client = $this->clients[$url];
        // $client['futures'][$requestId] = future;
        // return future; // $this->watch ($url, $messageHash, array_merge($request, $params), $messageHash);
        // throw new NotSupported($this->id . ' watchOrderBook not implemented yet');
        // return future;
    }

    public function fetch_order_book_snapshot ($symbol) {
        // todo => this is sync in php - make it async
        $snapshot = $this->fetch_order_book($symbol);
        $orderbook = $this->orderbooks[$symbol];
        $orderbook->update ($snapshot);
        // $asks = $orderbook['asks'];
        // for ($i = 0; $i < count($snapshot['asks']); $i++) {
        //     $asks->storeArray ($snapshot['asks'][$i]);
        // }
        // $bids = $orderbook['bids'];
        // for ($i = 0; $i < count($snapshot['bids']); $i++) {
        //     $bids->storeArray ($snapshot['bids'][$i]);
        // }
    }

    public function handle_order_book ($client, $message) {
        //
        //     {
        //         "e" => "depthUpdate", // Event type
        //         "E" => 123456789, // Event time
        //         "s" => "BNBBTC", // Symbol
        //         "U" => 157, // First update ID in event
        //         "u" => 160, // Final update ID in event
        //         "b" => array( // bids
        //             array( "0.0024", "10" ), // price, size
        //         ),
        //         "a" => array( // $asks
        //             array( "0.0026", "100" ), // price, size
        //         )
        //     }
        //
        $marketId = $this->safe_string($message, 's');
        $market = null;
        $symbol = null;
        if ($marketId !== null) {
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
            }
        }
        $name = 'depth';
        $messageHash = $market['lowercaseId'] . '@' . $name;
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the $deltas
        //
        //
        $fetching = false;
        if (!$fetching) {
            // fetch the snapshot in a separate async call
            // $this->spawn (array($this, 'fetch_order_book_snapshot'), ...)
            throw new NotSupported($this->id . ' snapshot $fetching is wip');
        }
        if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
            $orderbook = $this->orderbooks[$symbol];
            // resolve
            $client->resolve ($orderbook, $messageHash);
        } else {
            // accumulate $deltas
            $this->options['cache'][$symbol] = array();
            $this->options['cache'][$messageHash][] = $message;
        }
        // $orderbook = $this->order
        // $deltas = array();
        // $nonce = $message['u'];
        // for ($i = 0; $i < count($message['b']); $i++) {
        //     $bid = $message['b'][$i];
        //     $deltas[] = [$nonce, 'absolute', 'bids', floatval ($bid[0]), floatval ($bid[1])];
        // }
        // for ($i = 0; $i < count($message['a']); $i++) {
        //     $asks = $message['a'][$i];
        //     $deltas[] = [$nonce, 'absolute', 'asks', floatval ($asks[0]), floatval ($asks[1])];
        // }
        // $symbol = $this->parseSymbol ($message);
        // $incrementalBook = $this->orderbooks[$symbol];
        // $incrementalBook->update ($deltas);
        // $timestamp = $this->safe_integer($message, 'E');
        // $incrementalBook->message['timestamp'] = $timestamp;
        // $incrementalBook->message['datetime'] = $this->iso8601 ($timestamp);
        // $incrementalBook->message['nonce'] = $message['u'];
        // return $incrementalBook->orderBook;
    }

    public function sign_message ($client, $messageHash, $message, $params = array ()) {
        // todo => binance signMessage not implemented yet
        return $message;
    }

    public function handle_subscription_status ($client, $message) {
        //
        //     {
        //         "result" => null,
        //         "id" => 1574649734450
        //     }
        //
        return $message;
    }

    public function handle_message ($client, $message) {
        // $requestId = $this->safe_string(
        $methods = array(
            'depthUpdate' => array($this, 'handle_order_book'),
        );
        $event = $this->safe_string($message, 'e');
        $method = $this->safe_string($methods, $event);
        if ($method === null) {
            $requestId = $this->safe_string($message, 'id');
            if ($requestId !== null) {
                return $this->handle_subscription_status ($client, $message);
            }
            return $message;
        } else {
            return $this->call ($method, $client, $message);
        }
        // var_dump ($message);
        // exit ();
        //
        // $keys = is_array($client->futures) ? array_keys($client->futures) : array();
        // for ($i = 0; $i < count($keys); $i++) {
        //     $key = $keys[$i];
        //     $client->reject ()
        // }
        //
        // --------------------------------------------------------------------
        //
        // var_dump (new Date (), json_encode ($message, null, 4));
        // var_dump ('---------------------------------------------------------');
        // if (gettype($message) === 'array' && count(array_filter(array_keys($message), 'is_string')) == 0) {
        //     $channelId = (string) $message[0];
        //     $subscriptionStatus = $this->safe_value($this->options['subscriptionStatusByChannelId'], $channelId, array());
        //     $subscription = $this->safe_value($subscriptionStatus, 'subscription', array());
        //     $name = $this->safe_string($subscription, 'name');
        //     $methods = array(
        //         'book' => 'handleOrderBook',
        //         'ohlc' => 'handleOHLCV',
        //         'ticker' => 'handleTicker',
        //         'trade' => 'handleTrades',
        //     );
        //     $method = $this->safe_string($methods, $name);
        //     if ($method === null) {
        //         return $message;
        //     } else {
        //         return $this->$method ($client, $message);
        //     }
        // } else {
        //     if ($this->handleErrorMessage ($client, $message)) {
        //         $event = $this->safe_string($message, 'event');
        //         $methods = array(
        //             'heartbeat' => 'handleHeartbeat',
        //             'systemStatus' => 'handleSystemStatus',
        //             'subscriptionStatus' => 'handleSubscriptionStatus',
        //         );
        //         $method = $this->safe_string($methods, $event);
        //         if ($method === null) {
        //             return $message;
        //         } else {
        //             return $this->$method ($client, $message);
        //         }
        //     }
        // }
    }
}
