<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use \ccxtpro\ClientTrait; // websocket functionality
use Exception; // a common import
use \ccxt\ExchangeError;

class binance extends \ccxt\binance {

    use ClientTrait;

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'has' => array(
                'watchOrderBook' => true,
                'watchTrades' => true,
                'watchOHLCV' => true,
                'watchTicker' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://stream.binance.com:9443/ws',
                ),
            ),
            'options' => array(
                'watchOrderBookRate' => 100, // get updates every 100ms or 1000ms
                'tradesLimit' => 1000,
                'OHLCVLimit' => 3,
            ),
        ));
    }

    public function load_markets ($reload = false, $params = array ()) {
        $markets = parent::load_markets($reload, $params);
        $marketsByLowercaseId = $this->safe_value($this->options, 'marketsByLowercaseId');
        if (($marketsByLowercaseId === null) || $reload) {
            $marketsByLowercaseId = array();
            for ($i = 0; $i < count($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $market = $this->markets[$symbol];
                $lowercaseId = $this->safe_string_lower($market, 'id');
                $market['lowercaseId'] = $lowercaseId;
                $this->markets_by_id[$market['id']] = $market;
                $this->markets[$symbol] = $market;
                $marketsByLowercaseId[$lowercaseId] = $this->markets[$symbol];
            }
            $this->options['marketsByLowercaseId'] = $marketsByLowercaseId;
        }
        return $markets;
    }

    public function watch_order_book ($symbol, $limit = null, $params = array ()) {
        //
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/web-socket-streams.md#partial-book-depth-streams
        //
        // <$symbol>@depth<levels>@100ms or <$symbol>@depth<levels> (1000ms)
        // valid <levels> are 5, 10, or 20
        //
        if ($limit !== null) {
            if (($limit !== 5) && ($limit !== 10) && ($limit !== 20)) {
                throw new ExchangeError($this->id . ' watchOrderBook $limit argument must be null, 5, 10 or 20');
            }
        }
        $this->load_markets();
        $market = $this->market ($symbol);
        //
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/web-socket-streams.md#how-to-manage-a-local-order-book-correctly
        //
        // 1. Open a stream to wss://stream.binance.com:9443/ws/bnbbtc@depth.
        // 2. Buffer the events you receive from the stream.
        // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?$symbol=BNBBTC&$limit=1000 .
        // 4. Drop any event where u is <= lastUpdateId in the snapshot.
        // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
        // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
        // 7. The data in each event is the absolute quantity for a price level.
        // 8. If the quantity is 0, remove the price level.
        // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
        //
        $name = 'depth';
        $messageHash = $market['lowercaseId'] . '@' . $name;
        $url = $this->urls['api']['ws']; // . '/' . $messageHash;
        $requestId = $this->nonce ();
        $watchOrderBookRate = $this->safe_string($this->options, 'watchOrderBookRate', '100');
        $request = array(
            'method' => 'SUBSCRIBE',
            'params' => array(
                $messageHash . '@' . $watchOrderBookRate . 'ms',
            ),
            'id' => $requestId,
        );
        $subscription = array(
            'id' => (string) $requestId,
            'messageHash' => $messageHash,
            'name' => $name,
            'symbol' => $symbol,
            'method' => array($this, 'handle_order_book_subscription'),
            'limit' => $limit,
        );
        $message = array_merge($request, $params);
        // 1. Open a stream to wss://stream.binance.com:9443/ws/bnbbtc@depth.
        $future = $this->watch ($url, $messageHash, $message, $messageHash, $subscription);
        return $this->after ($future, array($this, 'limit_order_book'), $symbol, $limit, $params);
    }

    public function limit_order_book ($orderbook, $symbol, $limit = null, $params = array ()) {
        return $orderbook->limit ($limit);
    }

    public function fetch_order_book_snapshot ($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $messageHash = $this->safe_string($subscription, 'messageHash');
        // 3. Get a depth $snapshot from https://www.binance.com/api/v1/depth?$symbol=BNBBTC&limit=1000 .
        // todo => this is a synch blocking call in ccxt.php - make it async
        $snapshot = $this->fetch_order_book($symbol);
        $orderbook = $this->orderbooks[$symbol];
        $orderbook->reset ($snapshot);
        // unroll the accumulated deltas
        $messages = $orderbook->cache;
        for ($i = 0; $i < count($messages); $i++) {
            $message = $messages[$i];
            $this->handle_order_book_message ($client, $message, $orderbook);
        }
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function handle_delta ($bookside, $delta) {
        $price = $this->safe_float($delta, 0);
        $amount = $this->safe_float($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_deltas ($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta ($bookside, $deltas[$i]);
        }
    }

    public function handle_order_book_message ($client, $message, $orderbook) {
        $u = $this->safe_integer_2($message, 'u', 'lastUpdateId');
        // merge accumulated deltas
        // 4. Drop any event where $u is <= lastUpdateId in the snapshot.
        if ($u > $orderbook['nonce']) {
            $U = $this->safe_integer($message, 'U');
            // 5. The first processed event should have $U <= lastUpdateId+1 AND $u >= lastUpdateId+1.
            if (($U !== null) && (($U - 1) > $orderbook['nonce'])) {
                // todo => $client->reject from handleOrderBookMessage properly
                throw new ExchangeError($this->id . ' handleOrderBook received an out-of-order nonce');
            }
            $this->handle_deltas ($orderbook['asks'], $this->safe_value($message, 'a', array()));
            $this->handle_deltas ($orderbook['bids'], $this->safe_value($message, 'b', array()));
            $orderbook['nonce'] = $u;
            $timestamp = $this->safe_integer($message, 'E');
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601 ($timestamp);
        }
        return $orderbook;
    }

    public function handle_order_book ($client, $message) {
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the deltas
        //
        //     {
        //         "e" => "depthUpdate", // Event type
        //         "E" => 1577554482280, // Event time
        //         "s" => "BNBBTC", // Symbol
        //         "U" => 157, // First update ID in event
        //         "u" => 160, // Final update ID in event
        //         "b" => array( // bids
        //             array( "0.0024", "10" ), // price, size
        //         ),
        //         "a" => array( // asks
        //             array( "0.0026", "100" ), // price, size
        //         )
        //     }
        //
        $marketId = $this->safe_string($message, 's');
        $market = null;
        $symbol = null;
        if ($marketId !== null) {
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
            }
        }
        $name = 'depth';
        $messageHash = $market['lowercaseId'] . '@' . $name;
        $orderbook = $this->orderbooks[$symbol];
        if ($orderbook['nonce'] !== null) {
            // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
            // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
            $this->handle_order_book_message ($client, $message, $orderbook);
            $client->resolve ($orderbook, $messageHash);
        } else {
            // 2. Buffer the events you receive from the stream.
            $orderbook->cache[] = $message;
        }
    }

    public function sign_message ($client, $messageHash, $message, $params = array ()) {
        // todo => implement binance signMessage
        return $message;
    }

    public function handle_order_book_subscription ($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_string($subscription, 'limit');
        if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
            unset($this->orderbooks[$symbol]);
        }
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
        // fetch the snapshot in a separate async call
        $this->spawn (array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
    }

    public function handle_subscription_status ($client, $message) {
        //
        //     {
        //         "result" => null,
        //         "$id" => 1574649734450
        //     }
        //
        $id = $this->safe_string($message, 'id');
        $subscriptionsById = $this->index_by($client->subscriptions, 'id');
        $subscription = $this->safe_value($subscriptionsById, $id, array());
        $method = $this->safe_value($subscription, 'method');
        if ($method !== null) {
            $method($client, $message, $subscription);
        }
        return $message;
    }

    public function watch_trades ($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $name = 'trade';
        $messageHash = $market['lowercaseId'] . '@' . $name;
        $url = $this->urls['api']['ws']; // . '/' . $messageHash;
        $requestId = $this->nonce ();
        $request = array(
            'method' => 'SUBSCRIBE',
            'params' => array(
                $messageHash,
            ),
            'id' => $requestId,
        );
        $subscribe = array(
            'id' => $requestId,
        );
        $future = $this->watch ($url, $messageHash, $request, $messageHash, $subscribe);
        return $this->after ($future, $this->filterBySinceLimit, $since, $limit);
    }

    public function handle_trade ($client, $message) {
        // The Trade Streams push raw trade information; each trade has a unique buyer and seller.
        // Update Speed => Real-time
        //
        // {
        //   e => 'trade',
        //   E => 1579481530911,
        //   s => 'ETHBTC',
        //   t => 158410082,
        //   p => '0.01914100',
        //   q => '0.00700000',
        //   b => 586187049,
        //   a => 586186710,
        //   T => 1579481530910,
        //   m => false,
        //   M => true
        // }
        $marketId = $this->safe_string($message, 's');
        $market = null;
        $symbol = $marketId;
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
            $symbol = $market['symbol'];
        }
        $lowerCaseId = $this->safe_string_lower($message, 's');
        $event = $this->safe_string($message, 'e');
        $messageHash = $lowerCaseId . '@' . $event;
        $parsed = $this->parse_trade($message, $market);
        $array = $this->safe_value($this->trades, $symbol, $array());
        $array[] = $parsed;
        $length = is_array($array) ? count($array) : 0;
        if ($length > $this->options['tradesLimit']) {
            array_shift($array);
        }
        $this->trades[$symbol] = $array;
        $client->resolve ($array, $messageHash);
    }

    public function watch_ohlcv ($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $url = $this->urls['api']['ws'];
        $market = $this->market ($symbol);
        $marketId = $market['lowercaseId'];
        $interval = $this->timeframes[$timeframe];
        $name = 'kline_';
        $messageHash = $marketId . '@' . $name . $interval;
        $requestId = $this->nonce ();
        $request = array(
            'method' => 'SUBSCRIBE',
            'params' => array(
                $messageHash,
            ),
            'id' => $requestId,
        );
        $subscribe = array(
            'id' => $requestId,
        );
        return $this->watch ($url, $messageHash, $request, $messageHash, $subscribe);
    }

    public function handle_ohclv ($client, $message) {
        // {
        //   e => 'kline',
        //   E => 1579482921215,
        //   s => 'ETHBTC',
        //   k => {
        //     t => 1579482900000,
        //     T => 1579482959999,
        //     s => 'ETHBTC',
        //     i => '1m',
        //     f => 158411535,
        //     L => 158411550,
        //     o => '0.01913200',
        //     c => '0.01913500',
        //     h => '0.01913700',
        //     l => '0.01913200',
        //     v => '5.08400000',
        //     n => 16,
        //     x => false,
        //     q => '0.09728060',
        //     V => '3.30200000',
        //     Q => '0.06318500',
        //     B => '0'
        //   }
        // }
        $marketId = $this->safe_string($message, 's');
        $lowercaseMarketId = $this->safe_string_lower($message, 's');
        $event = $this->safe_string($message, 'e');
        $kline = $this->safe_value($message, 'k');
        $interval = $this->safe_string($kline, 'i');
        $messageHash = $lowercaseMarketId . '@' . $event . '_' . $interval;
        $timestamp = $this->safe_integer($kline, 't');
        $open = $this->safe_float($kline, 'o');
        $high = $this->safe_float($kline, 'h');
        $low = $this->safe_float($kline, 'l');
        $close = $this->safe_float($kline, 'c');
        $volume = $this->safe_float($kline, 'v');
        $parsed = array(
            $timestamp,
            $open,
            $high,
            $low,
            $close,
            $volume,
        );
        $symbol = $marketId;
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
            $symbol = $market['symbol'];
        }
        if (!(is_array($this->ohlcvs) && array_key_exists($symbol, $this->ohlcvs))) {
            $this->ohlcvs[$symbol] = array();
        }
        $stored = $this->ohlcvs[$symbol];
        $length = is_array($stored) ? count($stored) : 0;
        if ($length && $parsed[0] === $stored[$length - 1][0]) {
            $stored[$length - 1] = $parsed;
        } else {
            $stored[] = $parsed;
            if ($length . 1 > $this->options['OHLCVLimit']) {
                array_shift($stored);
            }
        }
        $this->ohlcvs[$symbol] = $stored;
        $client->resolve ($stored, $messageHash);
    }

    public function watch_ticker ($symbol, $params = array ()) {
        $this->load_markets();
        $url = $this->urls['api']['ws'];
        $market = $this->market ($symbol);
        $marketId = $market['lowercaseId'];
        $name = 'ticker';
        $messageHash = $marketId . '@' . $name;
        $requestId = $this->nonce ();
        $request = array(
            'method' => 'SUBSCRIBE',
            'params' => array(
                $messageHash,
            ),
            'id' => $requestId,
        );
        $subscribe = array(
            'id' => $requestId,
        );
        return $this->watch ($url, $messageHash, $request, $messageHash, $subscribe);
    }

    public function handle_ticker ($client, $message) {
        // 24hr rolling window ticker statistics for a single $symbol-> These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
        //
        // Update Speed => 1000ms
        // {
        //   e => '24hrTicker',
        //   E => 1579485598569,
        //   s => 'ETHBTC',
        //   p => '-0.00004000',
        //   P => '-0.209',
        //   w => '0.01920495',
        //   x => '0.01916500',
        //   c => '0.01912500',
        //   Q => '0.10400000',
        //   b => '0.01912200',
        //   B => '4.10400000',
        //   a => '0.01912500',
        //   A => '0.00100000',
        //   o => '0.01916500',
        //   h => '0.01956500',
        //   l => '0.01887700',
        //   v => '173518.11900000',
        //   q => '3332.40703994',
        //   O => 1579399197842,
        //   C => 1579485597842,
        //   F => 158251292,
        //   L => 158414513,
        //   n => 163222
        // }
        $event = 'ticker'; // $message['e'] === 24hrTicker
        $wsMarketId = $this->safe_string_lower($message, 's');
        $messageHash = $wsMarketId . '@' . $event;
        $timestamp = $this->safe_integer($message, 'C');
        $symbol = null;
        $marketId = $this->safe_string($message, 's');
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
            $symbol = $market['symbol'];
        }
        $last = $this->safe_float($message, 'c');
        $parsed = array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'high' => $this->safe_float($message, 'h'),
            'low' => $this->safe_float($message, 'l'),
            'bid' => $this->safe_float($message, 'b'),
            'bidVolume' => $this->safe_float($message, 'B'),
            'ask' => $this->safe_float($message, 'a'),
            'askVolume' => $this->safe_float($message, 'A'),
            'vwap' => $this->safe_float($message, 'w'),
            'open' => $this->safe_float($message, 'o'),
            'close' => $last,
            'last' => $last,
            'previousClose' => $this->safe_float($message, 'x'), // previous day close
            'change' => $this->safe_float($message, 'p'),
            'percentage' => $this->safe_float($message, 'P'),
            'average' => null,
            'baseVolume' => $this->safe_float($message, 'v'),
            'quoteVolume' => $this->safe_float($message, 'q'),
            'info' => $message,
        );
        $client->resolve ($parsed, $messageHash);
    }

    public function handle_message ($client, $message) {
        $methods = array(
            'depthUpdate' => array($this, 'handle_order_book'),
            'trade' => array($this, 'handle_trade'),
            'kline' => array($this, 'handle_ohclv'),
            '24hrTicker' => array($this, 'handle_ticker'),
        );
        $event = $this->safe_string($message, 'e');
        $method = $this->safe_value($methods, $event);
        if ($method === null) {
            $requestId = $this->safe_string($message, 'id');
            if ($requestId !== null) {
                return $this->handle_subscription_status ($client, $message);
            }
            return $message;
        } else {
            return $method($client, $message);
        }
    }
}
