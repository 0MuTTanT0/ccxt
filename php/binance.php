<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception as Exception; // a common import

class binance extends Exchange {

    public function describe () {
        return array_replace_recursive (parent::describe (), array (
            'has' => array (
                'fetchWsOrderBook' => true,
                'fetchWsOHLCV' => true,
                'fetchWsTrades' => true,
            ),
            'urls' => array (
                'api' => array (
                    'wss' => 'wss://stream.binance.com:9443/ws/',
                ),
            ),
        ));
    }

    public function get_ws_message_hash ($client, $response) {
        return $client->url;
    }

    public function fetch_ws_trades ($symbol) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $url = $this->urls['api']['websocket']['public'] . strtolower($market['id']) . '@trade';
        return $this->WsTradesMessage ($url, $url);
    }

    public function handle_ws_trades ($response) {
        $parsed = $this->parse_trade($response);
        $parsed['symbol'] = $this->parse_symbol ($response);
        return $parsed;
    }

    public function fetch_ws_ohlcv ($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $interval = $this->timeframes[$timeframe];
        $market = $this->market ($symbol);
        $url = $this->urls['api']['websocket']['public'] . strtolower($market['id']) . '@kline_' . $interval;
        return $this->WsOHLCVMessage ($url, $url);
    }

    public function handle_ws_ohlcv ($ohlcv) {
        $data = $ohlcv['k'];
        $timestamp = $this->safe_integer($data, 'T');
        $open = $this->safe_float($data, 'o');
        $high = $this->safe_float($data, 'h');
        $close = $this->safe_float($data, 'l');
        $low = $this->safe_float($data, 'c');
        $volume = $this->safe_float($data, 'v');
        return [$timestamp, $open, $high, $close, $low, $volume];
    }

    public function fetch_ws_order_book ($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $url = $this->urls['api']['websocket']['public'] . strtolower($market['id']) . '@depth';
        // if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
        //     $snapshot = $this->fetch_order_book($symbol, $limit, $params);
        //     $this->orderbooks[$symbol] = new IncrementalOrderBook ($snapshot);
        // }
        return $this->WsOrderBookMessage ($url, $url);
    }

    public function handle_ws_order_book ($orderBook) {
        $deltas = array();
        $nonce = $orderBook['u'];
        for ($i = 0; $i < count ($orderBook['b']); $i++) {
            $bid = $orderBook['b'][$i];
            $deltas[] = [$nonce, 'absolute', 'bids', floatval ($bid[0]), floatval ($bid[1])];
        }
        for ($i = 0; $i < count ($orderBook['a']); $i++) {
            $asks = $orderBook['a'][$i];
            $deltas[] = [$nonce, 'absolute', 'asks', floatval ($asks[0]), floatval ($asks[1])];
        }
        $symbol = $this->parse_symbol ($orderBook);
        $incrementalBook = $this->orderbooks[$symbol];
        $incrementalBook->update ($deltas);
        $timestamp = $this->safe_integer($orderBook, 'E');
        $incrementalBook->orderBook['timestamp'] = $timestamp;
        $incrementalBook->orderBook['datetime'] = $this->iso8601 ($timestamp);
        $incrementalBook->orderBook['nonce'] = $orderBook['u'];
        return $incrementalBook->orderBook;
    }

    public function parse_symbol ($message) {
        return $this->marketsById[$message['s']]['symbol'];
    }

    public function handle_ws_dropped ($client, $response, $messageHash) {
        $orderBookHash = 'wss://stream.binance.com:9443/ws/ethbtc@depth';
        if ($messageHash !== null && $messageHash->startsWith ($orderBookHash)) {
            $this->handle_ws_order_book ($response);
        }
    }
}
