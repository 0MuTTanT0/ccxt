<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;

class bitfinex extends \ccxt\bitfinex {

    use ClientTrait;

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchOrderBook' => true,
                'watchTrades' => true,
                'watchBalance' => false,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://api.bitfinex.com/ws/1',
                        'private' => 'wss://api.bitfinex.com/ws/1',
                    ),
                ),
            ),
        ));
    }

    public function subscribe ($channel, $symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $marketId = $market['id'];
        $url = $this->urls['api']['ws']['public'];
        $messageHash = $channel . ':' . $marketId;
        // $channel = 'trades';
        $request = array(
            'event' => 'subscribe',
            'channel' => $channel,
            'symbol' => $marketId,
            'messageHash' => $messageHash,
        );
        return $this->watch ($url, $messageHash, array_replace_recursive($request, $params), $messageHash);
    }

    public function watch_trades ($symbol, $since = null, $limit = null, $params = array ()) {
        $future = $this->subscribe ('trades', $symbol, $params);
        return $this->after ($future, $this->filterBySinceLimit, $since, $limit);
    }

    public function watch_ticker ($symbol, $params = array ()) {
        return $this->subscribe ('ticker', $symbol, $params);
    }

    public function handle_trades ($client, $message, $subscription) {
        //
        // initial snapshot
        //
        //     array(
        //         2,
        //             array(
        //             array( null, 1580565020, 9374.9, 0.005 ),
        //             array( null, 1580565004, 9374.9, 0.005 ),
        //             array( null, 1580565003, 9374.9, 0.005 ),
        //         )
        //     )
        //
        // when a $trade does not have an id yet
        //
        //     // channel id, update type, seq, time, price, amount
        //     array( 2, 'te', '28462857-BTCUSD', 1580565041, 9374.9, 0.005 ),
        //
        // when a $trade already has an id
        //
        //     // channel id, update type, seq, $trade id, time, price, amount
        //     array( 2, 'tu', '28462857-BTCUSD', 413357662, 1580565041, 9374.9, 0.005 )
        //
        $messageHash = $this->safe_value($subscription, 'messageHash');
        $marketId = $this->safe_string($subscription, 'pair');
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
            $symbol = $market['symbol'];
            $data = $this->safe_value($message, 1);
            $stored = $this->safe_value($this->trades, $symbol, array());
            if (gettype($data) === 'array' && count(array_filter(array_keys($data), 'is_string')) == 0) {
                $trades = $this->parse_trades($data, $market);
                for ($i = 0; $i < count($trades); $i++) {
                    $stored[] = $trades[$i];
                    $storedLength = is_array($stored) ? count($stored) : 0;
                    if ($storedLength > $this->options['tradesLimit']) {
                        array_shift($stored);
                    }
                }
            } else {
                $second = $this->safe_string($message, 1);
                if ($second !== 'tu') {
                    return;
                }
                $trade = $this->parse_trade($message, $market);
                $stored[] = $trade;
                $length = is_array($stored) ? count($stored) : 0;
                if ($length > $this->options['tradesLimit']) {
                    array_shift($stored);
                }
            }
            $this->trades[$symbol] = $stored;
            $client->resolve ($stored, $messageHash);
        }
        return $message;
    }

    public function parse_trade ($trade, $market = null) {
        //
        // snapshot $trade
        //
        //     // null, time, $price, $amount
        //     array( null, 1580565020, 9374.9, 0.005 ),
        //
        // when a $trade does not have an $id yet
        //
        //     // channel $id, update type, $seq, time, $price, $amount
        //     array( 2, 'te', '28462857-BTCUSD', 1580565041, 9374.9, 0.005 ),
        //
        // when a $trade already has an $id
        //
        //     // channel $id, update type, $seq, $trade $id, time, $price, $amount
        //     array( 2, 'tu', '28462857-BTCUSD', 413357662, 1580565041, 9374.9, 0.005 )
        //
        if (!gettype($trade) === 'array' && count(array_filter(array_keys($trade), 'is_string')) == 0) {
            return parent::parse_trade($trade, $market);
        }
        $tradeLength = is_array($trade) ? count($trade) : 0;
        $event = $this->safe_string($trade, 1);
        $id = null;
        if ($event === 'tu') {
            $id = $this->safe_string($trade, $tradeLength - 4);
        }
        $timestamp = $this->safe_timestamp($trade, $tradeLength - 3);
        $price = $this->safe_float($trade, $tradeLength - 2);
        $amount = $this->safe_float($trade, $tradeLength - 1);
        $side = null;
        if ($amount !== null) {
            $side = ($amount > 0) ? 'buy' : 'sell';
            $amount = abs($amount);
        }
        $cost = null;
        if (($price !== null) && ($amount !== null)) {
            $cost = $price * $amount;
        }
        $seq = $this->safe_string($trade, 2);
        $parts = explode('-', $seq);
        $marketId = $this->safe_string($parts, 1);
        $symbol = null;
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
        }
        if (($symbol === null) && ($market !== null)) {
            $symbol = $market['symbol'];
        }
        $takerOrMaker = null;
        $orderId = null;
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $orderId,
            'type' => null,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => null,
        );
    }

    public function handle_ticker ($client, $message, $subscription) {
        //
        //     array(
        //         2,             // 0 CHANNEL_ID integer Channel ID
        //         236.62,        // 1 BID float Price of $last highest bid
        //         9.0029,        // 2 BID_SIZE float Size of the $last highest bid
        //         236.88,        // 3 ASK float Price of $last lowest ask
        //         7.1138,        // 4 ASK_SIZE float Size of the $last lowest ask
        //         -1.02,         // 5 DAILY_CHANGE float Amount that the $last price has changed since yesterday
        //         0,             // 6 DAILY_CHANGE_PERC float Amount that the price has changed expressed in percentage terms
        //         236.52,        // 7 LAST_PRICE float Price of the $last trade.
        //         5191.36754297, // 8 VOLUME float Daily volume
        //         250.01,        // 9 HIGH float Daily high
        //         220.05,        // 10 LOW float Daily low
        //     )
        //
        $timestamp = $this->milliseconds ();
        $marketId = $this->safe_string($subscription, 'pair');
        $market = $this->markets_by_id[$marketId];
        $symbol = $market['symbol'];
        $channel = 'ticker';
        $messageHash = $channel . ':' . $marketId;
        $last = $this->safe_float($message, 7);
        $change = $this->safe_float($message, 5);
        $open = null;
        if (($last !== null) && ($change !== null)) {
            $open = $last - $change;
        }
        $result = array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'high' => $this->safe_float($message, 9),
            'low' => $this->safe_float($message, 10),
            'bid' => $this->safe_float($message, 1),
            'bidVolume' => null,
            'ask' => $this->safe_float($message, 3),
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $this->safe_float($message, 6),
            'average' => null,
            'baseVolume' => $this->safe_float($message, 8),
            'quoteVolume' => null,
            'info' => $message,
        );
        $this->tickers[$symbol] = $result;
        $client->resolve ($result, $messageHash);
    }

    public function watch_order_book ($symbol, $limit = null, $params = array ()) {
        if ($limit !== null) {
            if (($limit !== 25) && ($limit !== 100)) {
                throw new ExchangeError($this->id . ' watchOrderBook $limit argument must be null, 25 or 100');
            }
        }
        $request = array(
            // 'event' => 'subscribe', // added in subscribe()
            // 'channel' => channel,  // added in subscribe()
            // 'symbol' => marketId,  // added in subscribe()
            // 'prec' => 'P0', // string, level of price aggregation, 'P0', 'P1', 'P2', 'P3', 'P4', default P0
            // 'freq' => 'F0', // string, frequency of updates 'F0' = realtime, 'F1' = 2 seconds, default is 'F0'
            // 'len' => '25', // string, number of price points, '25', '100', default = '25'
        );
        $future = $this->subscribe ('book', $symbol, array_replace_recursive($request, $params));
        return $this->after ($future, array($this, 'limit_order_book'), $symbol, $limit, $params);
    }

    public function limit_order_book ($orderbook, $symbol, $limit = null, $params = array ()) {
        return $orderbook->limit ($limit);
    }

    public function handle_order_book ($client, $message, $subscription) {
        //
        // first $message (snapshot)
        //
        //     array(
        //         18691, // $channel id
        //         array(
        //             array( 7364.8, 10, 4.354802 ), // price, count, size > 0 = bid
        //             array( 7364.7, 1, 0.00288831 ),
        //             array( 7364.3, 12, 0.048 ),
        //             array( 7364.9, 3, -0.42028976 ), // price, count, size < 0 = ask
        //             array( 7365, 1, -0.25 ),
        //             array( 7365.5, 1, -0.00371937 ),
        //         )
        //     )
        //
        // subsequent updates
        //
        //     array(
        //         30,     // $channel id
        //         9339.9, // price
        //         0,      // count
        //         -1,     // size > 0 = bid, size < 0 = ask
        //     )
        //
        $marketId = $this->safe_string($subscription, 'pair');
        $market = $this->markets_by_id[$marketId];
        $symbol = $market['symbol'];
        $channel = 'book';
        $messageHash = $channel . ':' . $marketId;
        // if it is an initial snapshot
        if (gettype($message[1]) === 'array' && count(array_filter(array_keys($message[1]), 'is_string')) == 0) {
            $limit = $this->safe_integer($subscription, 'len');
            $this->orderbooks[$symbol] = $this->counted_order_book (array(), $limit);
            $orderbook = $this->orderbooks[$symbol];
            $deltas = $message[1];
            for ($i = 0; $i < count($deltas); $i++) {
                $delta = $deltas[$i];
                $amount = ($delta[2] < 0) ? -$delta[2] : $delta[2];
                $side = ($delta[2] < 0) ? 'asks' : 'bids';
                $bookside = $orderbook[$side];
                $bookside->store ($delta[0], $amount, $delta[1]);
            }
            $client->resolve ($orderbook, $messageHash);
        } else {
            $orderbook = $this->orderbooks[$symbol];
            $amount = ($message[3] < 0) ? -$message[3] : $message[3];
            $side = ($message[3] < 0) ? 'asks' : 'bids';
            $bookside = $orderbook[$side];
            $bookside->store ($message[1], $amount, $message[2]);
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function handle_heartbeat ($client, $message) {
        //
        // every second (approx) if no other updates are sent
        //
        //     array( "$event" => "heartbeat" )
        //
        $event = $this->safe_string($message, 'event');
        $client->resolve ($message, $event);
    }

    public function handle_system_status ($client, $message) {
        //
        // todo => answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         event => 'info',
        //         version => 2,
        //         serverId => 'e293377e-7bb7-427e-b28c-5db045b2c1d1',
        //         platform => array( status => 1 ), // 1 for operative, 0 for maintenance
        //     }
        //
        return $message;
    }

    public function handle_subscription_status ($client, $message) {
        //
        //     {
        //         event => 'subscribed',
        //         channel => 'book',
        //         chanId => 67473,
        //         symbol => 'tBTCUSD',
        //         prec => 'P0',
        //         freq => 'F0',
        //         len => '25',
        //         pair => 'BTCUSD'
        //     }
        //
        $channelId = $this->safe_string($message, 'chanId');
        $client->subscriptions[$channelId] = $message;
        return $message;
    }

    public function sign_message ($client, $messageHash, $message, $params = array ()) {
        // todo => bitfinex signMessage not implemented yet
        return $message;
    }

    public function handle_message ($client, $message) {
        if (gettype($message) === 'array' && count(array_filter(array_keys($message), 'is_string')) == 0) {
            $channelId = $this->safe_string($message, 0);
            //
            //     array(
            //         1231,
            //         'hb',
            //     )
            //
            if ($message[1] === 'hb') {
                return $message; // skip heartbeats within $subscription channels for now
            }
            $subscription = $this->safe_value($client->subscriptions, $channelId, array());
            $channel = $this->safe_string($subscription, 'channel');
            $methods = array(
                'book' => array($this, 'handle_order_book'),
                // 'ohlc' => $this->handleOHLCV,
                'ticker' => array($this, 'handle_ticker'),
                'trades' => array($this, 'handle_trades'),
            );
            $method = $this->safe_value($methods, $channel);
            if ($method === null) {
                return $message;
            } else {
                return $method($client, $message, $subscription);
            }
        } else {
            // todo add bitfinex handleErrorMessage
            //
            //     {
            //         $event => 'info',
            //         version => 2,
            //         serverId => 'e293377e-7bb7-427e-b28c-5db045b2c1d1',
            //         platform => array( status => 1 ), // 1 for operative, 0 for maintenance
            //     }
            //
            $event = $this->safe_string($message, 'event');
            if ($event !== null) {
                $methods = array(
                    'info' => array($this, 'handle_system_status'),
                    // 'book' => 'handleOrderBook',
                    'subscribed' => array($this, 'handle_subscription_status'),
                );
                $method = $this->safe_value($methods, $event);
                if ($method === null) {
                    return $message;
                } else {
                    return $method($client, $message);
                }
            }
        }
    }
}
