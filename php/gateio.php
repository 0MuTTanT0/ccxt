<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use \ccxtpro\ClientTrait; // websocket functionality
use Exception; // a common import
use \ccxt\ExchangeError;

class gateio extends \ccxt\gateio {

    use ClientTrait;

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'has' => array(
                'watchOrderBook' => true,
                'watchTicker' => true,
                'watchTrades' => true,
                'watchOHLCV' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://ws.gate.io/v3',
                ),
            ),
        ));
    }

    public function watch_order_book ($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $marketId = strtoupper($market['id']);
        $requestId = $this->nonce ();
        $url = $this->urls['api']['ws'];
        if (!$limit) {
            $limit = 30;
        } else if ($limit !== 1 && $limit !== 5 && $limit !== 10 && $limit !== 20 && $limit !== 30) {
            throw new ExchangeError($this->id . ' watchOrderBook $limit argument must be null, 1, 5, 10, 20, or 30');
        }
        $interval = $this->safe_string($params, 'interval', '0.00000001');
        $precision = -1 * log10 ($interval);
        if ($precision < 0 || $precision > 8 || fmod($precision, 1) !== 0) {
            throw new ExchangeError($this->id . ' invalid interval');
        }
        $messageHash = 'depth.update' . ':' . $marketId;
        $subscribeMessage = array(
            'id' => $requestId,
            'method' => 'depth.subscribe',
            'params' => [$marketId, $limit, $interval],
        );
        $future = $this->watch ($url, $messageHash, $subscribeMessage);
        return $this->after ($future, array($this, 'limit_order_book'), $symbol, $limit, $params);
    }

    public function sign_message ($client, $messageHash, $message, $params = array ()) {
        // todo => implement gateio signMessage
        return $message;
    }

    public function limit_order_book ($orderbook, $symbol, $limit = null, $params = array ()) {
        return $orderbook->limit ($limit);
    }

    public function handle_order_book ($client, $message) {
        $params = $message['params'];
        $clean = $params[0];
        $book = $params[1];
        $marketId = $params[2];
        $methodType = $message['method'];
        $messageHash = $methodType . ':' . $marketId;
        $orderBook = null;
        if ($clean) {
            $orderBook = $this->order_book(array());
            $this->orderbooks[$marketId] = $orderBook;
        } else {
            $orderBook = $this->orderbooks[$marketId];
        }
        $sides = ['bids', 'asks'];
        for ($j = 0; $j < 2; $j++) {
            $side = $sides[$j];
            if (is_array($book) && array_key_exists($side, $book)) {
                $bookSide = $book[$side];
                for ($i = 0; $i < count($bookSide); $i++) {
                    $order = $bookSide[$i];
                    $orderBook[$side].store (floatval ($order[0]), floatval ($order[1]));
                }
            }
        }
        $client->resolve ($orderBook, $messageHash);
    }

    public function watch_ticker ($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $marketId = strtoupper($market['id']);
        $requestId = $this->nonce ();
        $url = $this->urls['api']['ws'];
        $subscribeMessage = array(
            'id' => $requestId,
            'method' => 'ticker.subscribe',
            'params' => [$marketId],
        );
        $messageHash = 'ticker.update' . ':' . $marketId;
        return $this->watch ($url, $messageHash, $subscribeMessage);
    }

    public function handle_ticker ($client, $message) {
        $result = $message['params'];
        $marketId = $result[0];
        $normalMarketId = strtolower($marketId);
        $market = null;
        if (is_array($this->markets_by_id) && array_key_exists($normalMarketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$normalMarketId];
        }
        $ticker = $result[1];
        $parsed = $this->parse_ticker($ticker, $market);
        $methodType = $message['method'];
        $messageHash = $methodType . ':' . $marketId;
        $client->resolve ($parsed, $messageHash);
    }

    public function watch_trades ($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $marketId = strtoupper($market['id']);
        $requestId = $this->nonce ();
        $url = $this->urls['api']['ws'];
        $subscribeMessage = array(
            'id' => $requestId,
            'method' => 'trades.subscribe',
            'params' => [$marketId],
        );
        $messageHash = 'trades.update' . ':' . $marketId;
        return $this->watch ($url, $messageHash, $subscribeMessage);
    }

    public function handle_trades ($client, $messsage) {
        $result = $messsage['params'];
        $marketId = $result[0];
        $normalMarketId = strtolower($marketId);
        $market = null;
        if (is_array($this->markets_by_id) && array_key_exists($normalMarketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$normalMarketId];
        }
        $trades = $result[1];
        for ($i = 0; $i < count($trades); $i++) {
            $trade = $trades[$i];
            $parsed = $this->parse_trade($trade, $market);
            $this->trades[$marketId][] = $parsed;
        }
        $methodType = $messsage['method'];
        $messageHash = $methodType . ':' . $marketId;
        $client->resolve ($this->trades[$marketId], $messageHash);
    }

    public function watch_ohlcv ($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $marketId = strtoupper($market['id']);
        $requestId = $this->nonce ();
        $url = $this->urls['api']['ws'];
        $interval = intval ($this->timeframes[$timeframe]);
        $subscribeMessage = array(
            'id' => $requestId,
            'method' => 'kline.subscribe',
            'params' => [$marketId, $interval],
        );
        $messageHash = 'kline.update' . ':' . $marketId;
        return $this->watch ($url, $messageHash, $subscribeMessage);
    }

    public function handle_ohlcv ($client, $message) {
        $ohlcv = $message['params'][0];
        $marketId = $ohlcv[7];
        $normalMarketId = strtolower($marketId);
        $market = null;
        if (is_array($this->markets_by_id) && array_key_exists($normalMarketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$normalMarketId];
        }
        $parsed = $this->parse_ohlcv($ohlcv, $market);
        $methodType = $message['method'];
        $messageHash = $methodType . ':' . $marketId;
        $client->resolve ($parsed, $messageHash);
    }

    public function handle_message ($client, $message) {
        $methods = array(
            'depth.update' => array($this, 'handle_order_book'),
            'ticker.update' => array($this, 'handle_ticker'),
            'trades.update' => array($this, 'handle_trades'),
            'kline.update' => array($this, 'handle_ohlcv'),
        );
        $methodType = $this->safe_string($message, 'method');
        $method = $this->safe_value($methods, $methodType);
        if ($method) {
            $method($client, $message);
        }
    }
}
