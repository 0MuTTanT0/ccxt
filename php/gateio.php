<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\AuthenticationError;
use \ccxt\ArgumentsRequired;
use \ccxt\NotSupported;
use \ccxt\InvalidNonce;

class gateio extends \ccxt\async\gateio {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchBalance' => true,
                'watchOrders' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://ws.gate.io/v4',
                    'spot' => 'wss://api.gateio.ws/ws/v4/',
                    'swap' => array(
                        'usdt' => 'wss://fx-ws.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws.gateio.ws/v4/ws/btc',
                    ),
                    'future' => array(
                        'usdt' => 'wss://fx-ws.gateio.ws/v4/ws/delivery/usdt',
                        'btc' => 'wss://fx-ws.gateio.ws/v4/ws/delivery/btc',
                    ),
                    'option' => 'wss://op-ws.gateio.live/v4/ws',
                ),
                'test' => array(
                    'swap' => array(
                        'usdt' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/btc',
                    ),
                    'future' => array(
                        'usdt' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/btc',
                    ),
                    'option' => 'wss://op-ws-testnet.gateio.live/v4/ws',
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
                'watchTradesSubscriptions' => array(),
                'watchTickerSubscriptions' => array(),
                'watchOrderBookSubscriptions' => array(),
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        '2' => '\\ccxt\\BadRequest',
                        '4' => '\\ccxt\\AuthenticationError',
                        '6' => '\\ccxt\\AuthenticationError',
                        '11' => '\\ccxt\\AuthenticationError',
                    ),
                ),
            ),
        ));
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $symbol = $market['symbol'];
        $marketId = $market['id'];
        $options = $this->safe_value($this->options, 'watchOrderBook', array());
        $defaultLimit = $this->safe_integer($options, 'limit', 20);
        if (!$limit) {
            $limit = $defaultLimit;
        }
        $interval = $this->safe_string($params, 'interval', '1000ms');
        $type = $market['type'];
        $messageType = $this->get_uniform_type($type);
        $method = $messageType . '.' . 'order_book_update';
        $messageHash = $method . ':' . $market['symbol'];
        $url = $this->get_url_by_market_type($type, $market['inverse']);
        $payload = array( $marketId, $interval );
        if ($type !== 'spot') {
            // contract pairs require $limit in the $payload
            $stringLimit = (string) $limit;
            $payload[] = $stringLimit;
        }
        $subscriptionParams = array(
            'method' => array($this, 'handle_order_book_subscription'),
            'symbol' => $symbol,
            'limit' => $limit,
        );
        $orderbook = yield $this->subscribe_public($url, $method, $messageHash, $payload, $subscriptionParams);
        return $orderbook->limit ($limit);
    }

    public function handle_order_book_subscription($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_integer($subscription, 'limit');
        if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
            unset($this->orderbooks[$symbol]);
        }
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
        $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
    }

    public function fetch_order_book_snapshot($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_integer($subscription, 'limit');
        $messageHash = $this->safe_string($subscription, 'messageHash');
        try {
            $snapshot = yield $this->fetch_order_book($symbol, $limit);
            $orderbook = $this->orderbooks[$symbol];
            $messages = $orderbook->cache;
            $firstMessage = $this->safe_value($messages, 0, array());
            $result = $this->safe_value($firstMessage, 'result');
            $seqNum = $this->safe_integer($result, 'U');
            $nonce = $this->safe_integer($snapshot, 'nonce');
            // if the received $snapshot is earlier than the first cached delta
            // then we cannot align it with the cached deltas and we need to
            // retry synchronizing in $maxAttempts
            if (($seqNum === null) || ($nonce < $seqNum)) {
                $maxAttempts = $this->safe_integer($this->options, 'maxOrderBookSyncAttempts', 3);
                $numAttempts = $this->safe_integer($subscription, 'numAttempts', 0);
                // retry to syncrhonize if we haven't reached $maxAttempts yet
                if ($numAttempts < $maxAttempts) {
                    // safety guard
                    if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                        $numAttempts = $this->sum($numAttempts, 1);
                        $subscription['numAttempts'] = $numAttempts;
                        $client->subscriptions[$messageHash] = $subscription;
                        $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
                    }
                } else {
                    // throw upon failing to synchronize in $maxAttempts
                    throw new InvalidNonce($this->id . ' failed to synchronize WebSocket feed with the $snapshot for $symbol ' . $symbol . ' in ' . (string) $maxAttempts . ' attempts');
                }
            } else {
                $orderbook->reset ($snapshot);
                // unroll the accumulated deltas
                for ($i = 0; $i < count($messages); $i++) {
                    $message = $messages[$i];
                    $this->handle_order_book_message($client, $message, $orderbook);
                }
                $this->orderbooks[$symbol] = $orderbook;
                $client->resolve ($orderbook, $messageHash);
            }
        } catch (Exception $e) {
            $client->reject ($e, $messageHash);
        }
    }

    public function handle_order_book($client, $message) {
        //
        //  {
        //      "time":1649770575,
        //      "channel":"spot.order_book_update",
        //      "event":"update",
        //      "result":{
        //         "t":1649770575537,
        //         "e":"depthUpdate",
        //         "E":1649770575,
        //         "s":"LTC_USDT",
        //         "U":2622528153,
        //         "u":2622528265,
        //         "b":[
        //            ["104.18","3.9398"],
        //            ["104.56","19.0603"],
        //            ["104.94","0"],
        //            ["103.72","0"],
        //            ["105.01","52.6186"],
        //            ["104.76","0"],
        //            ["104.97","0"],
        //            ["104.71","0"],
        //            ["104.84","25.8604"],
        //            ["104.51","47.6508"],
        //         ],
        //         "a":[
        //            ["105.26","40.5519"],
        //            ["106.08","35.4396"],
        //            ["105.2","0"],
        //            ["105.45","8.5834"],
        //            ["105.5","20.17"],
        //            ["105.11","54.8359"],
        //            ["105.52","28.5605"],
        //            ["105.27","6.6325"],
        //            ["105.3","4.291446"],
        //            ["106.03","9.712"],
        //         ]
        //      }
        //   }
        //
        $channel = $this->safe_string($message, 'channel');
        $result = $this->safe_value($message, 'result');
        $marketId = $this->safe_string($result, 's');
        $symbol = $this->safe_symbol($marketId);
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook['nonce'] === null) {
            $orderbook->cache[] = $message;
        } else {
            $messageHash = $channel . ':' . $symbol;
            $this->handle_order_book_message($client, $message, $orderbook, $messageHash);
        }
    }

    public function handle_order_book_message($client, $message, $orderbook, $messageHash = null) {
        //
        // spot
        //
        //     {
        //         time => 1650189272,
        //         channel => 'spot.order_book_update',
        //         event => 'update',
        //         $result => {
        //             t => 1650189272515,
        //             e => 'depthUpdate',
        //             E => 1650189272,
        //             s => 'GMT_USDT',
        //             U => 140595902,
        //             u => 140595902,
        //             b => array(
        //                 array( '2.51518', '228.119' ),
        //                 array( '2.50587', '1510.11' ),
        //                 array( '2.49944', '67.6' ),
        //             ),
        //             a => array(
        //                 array( '2.5182', '4.199' ),
        //                 array( '2.51926', '1874' ),
        //                 array( '2.53528', '96.529' ),
        //             )
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         id => null,
        //         time => 1650188898,
        //         channel => 'futures.order_book_update',
        //         event => 'update',
        //         error => null,
        //         $result => {
        //             t => 1650188898938,
        //             s => 'GMT_USDT',
        //             U => 1577718307,
        //             u => 1577719254,
        //             b => array(
        //                 array( p => '2.5178', s => 0 ),
        //                 array( p => '2.5179', s => 0 ),
        //                 array( p => '2.518', s => 0 ),
        //             ),
        //             a => array(
        //                 array( p => '2.52', s => 0 ),
        //                 array( p => '2.5201', s => 0 ),
        //                 array( p => '2.5203', s => 0 ),
        //             )
        //         }
        //     }
        //
        $result = $this->safe_value($message, 'result');
        $prevSeqNum = $this->safe_integer($result, 'U');
        $seqNum = $this->safe_integer($result, 'u');
        $nonce = $orderbook['nonce'];
        // we have to add +1 because if the current seqNumber on iteration X is 5
        // on the iteration X+1, $prevSeqNum will be (5+1)
        $nextNonce = $this->sum($nonce, 1);
        if (($prevSeqNum <= $nextNonce) && ($seqNum >= $nextNonce)) {
            $asks = $this->safe_value($result, 'a', array());
            $bids = $this->safe_value($result, 'b', array());
            $this->handle_deltas($orderbook['asks'], $asks);
            $this->handle_deltas($orderbook['bids'], $bids);
            $orderbook['nonce'] = $seqNum;
            $timestamp = $this->safe_integer($result, 't');
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
            if ($messageHash !== null) {
                $client->resolve ($orderbook, $messageHash);
            }
        }
        return $orderbook;
    }

    public function handle_delta($bookside, $delta) {
        $price = null;
        $amount = null;
        if (gettype($delta) === 'array' && count(array_filter(array_keys($delta), 'is_string')) == 0) {
            // spot
            $price = $this->safe_float($delta, 0);
            $amount = $this->safe_float($delta, 1);
        } else {
            // swap
            $price = $this->safe_float($delta, 'p');
            $amount = $this->safe_float($delta, 's');
        }
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $market['id'];
        $type = $market['type'];
        $messageType = $this->get_uniform_type($type);
        $channel = $messageType . '.' . 'tickers';
        $messageHash = $channel . '.' . $market['symbol'];
        $payload = array( $marketId );
        $url = $this->get_url_by_market_type($type, $market['inverse']);
        return yield $this->subscribe_public($url, $channel, $messageHash, $payload);
    }

    public function handle_ticker($client, $message) {
        //
        //    {
        //        time => 1649326221,
        //        $channel => 'spot.tickers',
        //        event => 'update',
        //        $result => {
        //          currency_pair => 'BTC_USDT',
        //          last => '43444.82',
        //          lowest_ask => '43444.82',
        //          highest_bid => '43444.81',
        //          change_percentage => '-4.0036',
        //          base_volume => '5182.5412425462',
        //          quote_volume => '227267634.93123952',
        //          high_24h => '47698',
        //          low_24h => '42721.03'
        //        }
        //    }
        //
        $channel = $this->safe_string($message, 'channel');
        $result = $this->safe_value($message, 'result');
        if (gettype($result) === 'array' && count(array_filter(array_keys($result), 'is_string')) != 0) {
            $result = array( $result );
        }
        for ($i = 0; $i < count($result); $i++) {
            $ticker = $result[$i];
            $parsed = $this->parse_ticker($ticker);
            $symbol = $parsed['symbol'];
            $this->tickers[$symbol] = $parsed;
            $messageHash = $channel . '.' . $symbol;
            $client->resolve ($this->tickers[$symbol], $messageHash);
        }
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $market['id'];
        $uppercaseId = strtoupper($marketId);
        $requestId = $this->nonce();
        $url = $this->urls['api']['ws'];
        $options = $this->safe_value($this->options, 'watchTrades', array());
        $subscriptions = $this->safe_value($options, 'subscriptions', array());
        $subscriptions[$uppercaseId] = true;
        $options['subscriptions'] = $subscriptions;
        $this->options['watchTrades'] = $options;
        $subscribeMessage = array(
            'id' => $requestId,
            'method' => 'trades.subscribe',
            'params' => is_array($subscriptions) ? array_keys($subscriptions) : array(),
        );
        $subscription = array(
            'id' => $requestId,
        );
        $messageHash = 'trades.update' . ':' . $marketId;
        $trades = yield $this->watch($url, $messageHash, $subscribeMessage, $messageHash, $subscription);
        if ($this->newUpdates) {
            $limit = $trades->getLimit ($symbol, $limit);
        }
        return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
    }

    public function handle_trades($client, $message) {
        //
        //     array(
        //         'BTC_USDT',
        //         array(
        //             array(
        //                 id => 221994511,
        //                 time => 1580311438.618647,
        //                 price => '9309',
        //                 amount => '0.0019',
        //                 type => 'sell'
        //             ),
        //             array(
        //                 id => 221994501,
        //                 time => 1580311433.842509,
        //                 price => '9311.31',
        //                 amount => '0.01',
        //                 type => 'buy'
        //             ),
        //         )
        //     )
        //
        $params = $this->safe_value($message, 'params', array());
        $marketId = $this->safe_string($params, 0);
        $market = $this->safe_market($marketId, null, '_');
        $symbol = $market['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $trades = $this->safe_value($params, 1, array());
        $parsed = $this->parse_trades($trades, $market);
        for ($i = 0; $i < count($parsed); $i++) {
            $stored->append ($parsed[$i]);
        }
        $methodType = $message['method'];
        $messageHash = $methodType . ':' . $marketId;
        $client->resolve ($stored, $messageHash);
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $market['id'];
        $type = $market['type'];
        $interval = $this->timeframes[$timeframe];
        $messageType = $this->get_uniform_type($type);
        $method = $messageType . '.candlesticks';
        $messageHash = $method . ':' . $interval . ':' . $market['symbol'];
        $url = $this->get_url_by_market_type($type, $market['inverse']);
        $payload = [$interval, $marketId];
        $ohlcv = yield $this->subscribe_public($url, $method, $messageHash, $payload);
        if ($this->newUpdates) {
            $limit = $ohlcv->getLimit ($symbol, $limit);
        }
        return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
    }

    public function handle_ohlcv($client, $message) {
        //
        // {
        //     "time" => 1606292600,
        //     "channel" => "spot.candlesticks",
        //     "event" => "update",
        //     "result" => {
        //       "t" => "1606292580", // total volume
        //       "v" => "2362.32035", // volume
        //       "c" => "19128.1", // close
        //       "h" => "19128.1", // high
        //       "l" => "19128.1", // low
        //       "o" => "19128.1", // open
        //       "n" => "1m_BTC_USDT" // sub
        //     }
        //   }
        //
        $channel = $this->safe_string($message, 'channel');
        $result = $this->safe_value($message, 'result');
        $isArray = gettype($result) === 'array' && count(array_filter(array_keys($result), 'is_string')) == 0;
        if (!$isArray) {
            $result = [$result];
        }
        $marketIds = array();
        for ($i = 0; $i < count($result); $i++) {
            $ohlcv = $result[$i];
            $subscription = $this->safe_string($ohlcv, 'n', '');
            $parts = explode('_', $subscription);
            $timeframe = $this->safe_string($parts, 0);
            $prefix = $timeframe . '_';
            $marketId = str_replace($prefix, '', $subscription);
            $symbol = $this->safe_symbol($marketId, null, '_');
            $parsed = $this->parse_ohlcv($ohlcv);
            $stored = $this->safe_value($this->ohlcvs, $symbol);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol] = $stored;
            }
            $stored->append ($parsed);
            $marketIds[$symbol] = $timeframe;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $symbol = $keys[$i];
            $timeframe = $marketIds[$symbol];
            $interval = $this->timeframes[$timeframe];
            $hash = $channel . ':' . $interval . ':' . $symbol;
            $stored = $this->safe_value($this->ohlcvs, $symbol);
            $client->resolve ($stored, $hash);
        }
    }

    public function authenticate($params = array ()) {
        $url = $this->urls['api']['ws'];
        $client = $this->client($url);
        $future = $client->future ('authenticated');
        $method = 'server.sign';
        $authenticate = $this->safe_value($client->subscriptions, $method);
        if ($authenticate === null) {
            $requestId = $this->milliseconds();
            $requestIdString = (string) $requestId;
            $signature = $this->hmac($this->encode($requestIdString), $this->encode($this->secret), 'sha512', 'hex');
            $authenticateMessage = array(
                'id' => $requestId,
                'method' => $method,
                'params' => array( $this->apiKey, $signature, $requestId ),
            );
            $subscribe = array(
                'id' => $requestId,
                'method' => array($this, 'handle_authentication_message'),
            );
            $this->spawn(array($this, 'watch'), $url, $requestId, $authenticateMessage, $method, $subscribe);
        }
        return yield $future;
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $subType = null;
        $type = null;
        $marketId = '!all';
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $type = $market['type'];
            $marketId = $market['id'];
        } else {
            list($type, $params) = $this->handle_market_type_and_params('watchMyTrades', null, $params);
            if ($type !== 'spot') {
                $options = $this->safe_value($this->options, 'watchMyTrades', array());
                $subType = $this->safe_value($options, 'subType', 'linear');
                $subType = $this->safe_value($params, 'subType', $subType);
                $params = $this->omit($params, 'subType');
            }
        }
        $messageType = $this->get_uniform_type($type);
        $method = $messageType . '.usertrades';
        $messageHash = $method;
        if ($symbol !== null) {
            $messageHash .= ':' . $symbol;
        }
        $isInverse = ($subType === 'inverse');
        $url = $this->get_url_by_market_type($type, $isInverse);
        $payload = array( $marketId );
        // uid required for non spot markets
        $requiresUid = ($type !== 'spot');
        $trades = yield $this->subscribe_private($url, $method, $messageHash, $payload, $requiresUid);
        if ($this->newUpdates) {
            $limit = $trades->getLimit ($symbol, $limit);
        }
        return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
    }

    public function handle_my_trades($client, $message) {
        //
        // {
        //     "time" => 1543205083,
        //     "channel" => "futures.usertrades",
        //     "event" => "update",
        //     "error" => null,
        //     "result" => array(
        //       {
        //         "id" => "3335259",
        //         "create_time" => 1628736848,
        //         "create_time_ms" => 1628736848321,
        //         "contract" => "BTC_USD",
        //         "order_id" => "4872460",
        //         "size" => 1,
        //         "price" => "40000.4",
        //         "role" => "maker"
        //       }
        //     )
        // }
        //
        $result = $this->safe_value($message, 'result', array());
        $channel = $this->safe_string($message, 'channel');
        $tradesLength = is_array($result) ? count($result) : 0;
        if ($tradesLength === 0) {
            return;
        }
        $cachedTrades = $this->myTrades;
        if ($cachedTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $cachedTrades = new ArrayCacheBySymbolById ($limit);
        }
        $parsed = $this->parse_trades($result);
        $marketIds = array();
        for ($i = 0; $i < count($parsed); $i++) {
            $trade = $parsed[$i];
            $cachedTrades->append ($trade);
            $symbol = $trade['symbol'];
            $marketIds[$symbol] = true;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $market = $keys[$i];
            $hash = $channel . ':' . $market;
            $client->resolve ($cachedTrades, $hash);
        }
        $client->resolve ($cachedTrades, $channel);
    }

    public function watch_balance($params = array ()) {
        yield $this->load_markets();
        $this->check_required_credentials();
        $url = $this->urls['api']['ws'];
        yield $this->authenticate();
        $requestId = $this->nonce();
        $method = 'balance.update';
        $subscribeMessage = array(
            'id' => $requestId,
            'method' => 'balance.subscribe',
            'params' => array(),
        );
        $subscription = array(
            'id' => $requestId,
            'method' => array($this, 'handle_balance_subscription'),
        );
        return yield $this->watch($url, $method, $subscribeMessage, $method, $subscription);
    }

    public function fetch_balance_snapshot() {
        yield $this->load_markets();
        $this->check_required_credentials();
        $url = $this->urls['api']['ws'];
        yield $this->authenticate();
        $requestId = $this->nonce();
        $method = 'balance.query';
        $subscribeMessage = array(
            'id' => $requestId,
            'method' => $method,
            'params' => array(),
        );
        $subscription = array(
            'id' => $requestId,
            'method' => array($this, 'handle_balance_snapshot'),
        );
        return yield $this->watch($url, $requestId, $subscribeMessage, $method, $subscription);
    }

    public function handle_balance_snapshot($client, $message) {
        $messageHash = $this->safe_string($message, 'id');
        $result = $this->safe_value($message, 'result');
        $this->handle_balance_message($client, $messageHash, $result);
        $client->resolve ($this->balance, 'balance.update');
        if (is_array($client->subscriptions) && array_key_exists('balance.query', $client->subscriptions)) {
            unset($client->subscriptions['balance.query']);
        }
    }

    public function handle_balance($client, $message) {
        $messageHash = $message['method'];
        $result = $message['params'][0];
        $this->handle_balance_message($client, $messageHash, $result);
    }

    public function handle_balance_message($client, $messageHash, $result) {
        $keys = is_array($result) ? array_keys($result) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $account = $this->account();
            $key = $keys[$i];
            $code = $this->safe_currency_code($key);
            $balance = $result[$key];
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'freeze');
            $this->balance[$code] = $account;
        }
        $this->balance = $this->safe_balance($this->balance);
        $client->resolve ($this->balance, $messageHash);
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' watchOrders requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $type = 'spot';
        if ($market['future'] || $market['swap']) {
            $type = 'futures';
        } else if ($market['option']) {
            $type = 'options';
        }
        $method = $type . '.orders';
        $messageHash = $method;
        $messageHash = $method . ':' . $market['id'];
        $url = $this->get_url_by_market_type($market['type'], $market['inverse']);
        $payload = [$market['id']];
        // uid required for non spot markets
        $requiresUid = ($type !== 'spot');
        $orders = yield $this->subscribe_private($url, $method, $messageHash, $payload, $requiresUid);
        if ($this->newUpdates) {
            $limit = $orders->getLimit ($symbol, $limit);
        }
        return $this->filter_by_since_limit($orders, $since, $limit, 'timestamp', true);
    }

    public function handle_order($client, $message) {
        //
        // {
        //     "time" => 1605175506,
        //     "channel" => "spot.orders",
        //     "event" => "update",
        //     "result" => array(
        //       {
        //         "id" => "30784435",
        //         "user" => 123456,
        //         "text" => "t-abc",
        //         "create_time" => "1605175506",
        //         "create_time_ms" => "1605175506123",
        //         "update_time" => "1605175506",
        //         "update_time_ms" => "1605175506123",
        //         "event" => "put",
        //         "currency_pair" => "BTC_USDT",
        //         "type" => "limit",
        //         "account" => "spot",
        //         "side" => "sell",
        //         "amount" => "1",
        //         "price" => "10001",
        //         "time_in_force" => "gtc",
        //         "left" => "1",
        //         "filled_total" => "0",
        //         "fee" => "0",
        //         "fee_currency" => "USDT",
        //         "point_fee" => "0",
        //         "gt_fee" => "0",
        //         "gt_discount" => true,
        //         "rebated_fee" => "0",
        //         "rebated_fee_currency" => "USDT"
        //       }
        //     )
        // }
        //
        $orders = $this->safe_value($message, 'result', array());
        $channel = $this->safe_string($message, 'channel');
        $ordersLength = is_array($orders) ? count($orders) : 0;
        if ($ordersLength > 0) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            if ($this->orders === null) {
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $stored = $this->orders;
            $marketIds = array();
            $parsedOrders = $this->parse_orders($orders);
            for ($i = 0; $i < count($parsedOrders); $i++) {
                $parsed = $parsedOrders[$i];
                // inject order status
                $info = $this->safe_value($parsed, 'info');
                $event = $this->safe_string($info, 'event');
                if ($event === 'put') {
                    $parsed['status'] = 'open';
                } else if ($event === 'finish') {
                    $parsed['status'] = 'closed';
                }
                $stored->append ($parsed);
                $symbol = $parsed['symbol'];
                $market = $this->market($symbol);
                $marketIds[$market['id']] = true;
            }
            $keys = is_array($marketIds) ? array_keys($marketIds) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $messageHash = $channel . ':' . $keys[$i];
                $client->resolve ($this->orders, $messageHash);
            }
        }
    }

    public function handle_authentication_message($client, $message, $subscription) {
        $result = $this->safe_value($message, 'result');
        $status = $this->safe_string($result, 'status');
        if ($status === 'success') {
            // $client->resolve (true, 'authenticated') will delete the $future
            // we want to remember that we are authenticated in subsequent call to private methods
            $future = $this->safe_value($client->futures, 'authenticated');
            if ($future !== null) {
                $future->resolve (true);
            }
        } else {
            // delete authenticate subscribeHash to release the "subscribe lock"
            // allows subsequent calls to subscribe to reauthenticate
            // avoids sending two authentication messages before receiving a reply
            $error = new AuthenticationError ($this->id . ' handleAuthenticationMessage() error');
            $client->reject ($error, 'authenticated');
            if (is_array($client->subscriptions) && array_key_exists('server.sign', $client->subscriptions)) {
                unset($client->subscriptions['server.sign']);
            }
        }
    }

    public function handle_error_message($client, $message) {
        // {
        //     time => 1647274664,
        //     channel => 'futures.orders',
        //     event => 'subscribe',
        //     $error => array( $code => 2, $message => 'unknown contract BTC_USDT_20220318' ),
        // }
        // {
        //     time => 1647276473,
        //     channel => 'futures.orders',
        //     event => 'subscribe',
        //     $error => array(
        //       $code => 4,
        //       $message => 'array("label":"INVALID_KEY","message":"Invalid key provided")\n'
        //     ),
        //     result => null
        //   }
        $error = $this->safe_value($message, 'error', array());
        $code = $this->safe_integer($error, 'code');
        if ($code !== null) {
            $id = $this->safe_string($message, 'id');
            $subscriptionsById = $this->index_by($client->subscriptions, 'id');
            $subscription = $this->safe_value($subscriptionsById, $id);
            if ($subscription !== null) {
                try {
                    $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $code, $this->json($message));
                } catch (Exception $e) {
                    $messageHash = $this->safe_string($subscription, 'messageHash');
                    $client->reject ($e, $messageHash);
                    $client->reject ($e, $id);
                    if (is_array($client->subscriptions) && array_key_exists($id, $client->subscriptions)) {
                        unset($client->subscriptions[$id]);
                    }
                }
            }
        }
    }

    public function handle_balance_subscription($client, $message, $subscription) {
        $this->spawn(array($this, 'fetch_balance_snapshot'));
    }

    public function handle_subscription_status($client, $message) {
        $messageId = $this->safe_integer($message, 'id');
        if ($messageId !== null) {
            $subscriptionsById = $this->index_by($client->subscriptions, 'id');
            $subscription = $this->safe_value($subscriptionsById, $messageId, array());
            $method = $this->safe_value($subscription, 'method');
            if ($method !== null) {
                $method($client, $message, $subscription);
            }
            $client->resolve ($message, $messageId);
        }
    }

    public function handle_message($client, $message) {
        // subscribe
        // {
        //     time => 1649062304,
        //     id => 1649062303,
        //     $channel => 'spot.candlesticks',
        //     $event => 'subscribe',
        //     result => array( status => 'success' )
        // }
        // candlestick
        // {
        //     time => 1649063328,
        //     $channel => 'spot.candlesticks',
        //     $event => 'update',
        //     result => {
        //       t => '1649063280',
        //       v => '58932.23174896',
        //       c => '45966.47',
        //       h => '45997.24',
        //       l => '45966.47',
        //       o => '45975.18',
        //       n => '1m_BTC_USDT',
        //       a => '1.281699'
        //     }
        //  }
        // orders
        // {
        //     "time" => 1630654851,
        //     "channel" => "options.orders", or futures.orders or spot.orders
        //     "event" => "update",
        //     "result" => array(
        //        {
        //           "contract" => "BTC_USDT-20211130-65000-C",
        //           "create_time" => 1637897000,
        //             (...)
        //     )
        // }
        // orderbook
        // {
        //     time => 1649770525,
        //     $channel => 'spot.order_book_update',
        //     $event => 'update',
        //     result => {
        //       t => 1649770525653,
        //       e => 'depthUpdate',
        //       E => 1649770525,
        //       s => 'LTC_USDT',
        //       U => 2622525645,
        //       u => 2622525665,
        //       b => [
        //         [Array], [Array],
        //         [Array], [Array],
        //         [Array], [Array],
        //         [Array], [Array],
        //         [Array], [Array],
        //         [Array]
        //       ],
        //       a => [
        //         [Array], [Array],
        //         [Array], [Array],
        //         [Array], [Array],
        //         [Array], [Array],
        //         [Array], [Array],
        //         [Array]
        //       ]
        //     }
        //   }
        $this->handle_error_message($client, $message);
        $methods = array(
            // missing migration to v4
            'balance.update' => array($this, 'handle_balance'),
        );
        $methodType = $this->safe_string($message, 'method');
        $method = $this->safe_value($methods, $methodType);
        if ($method === null) {
            $event = $this->safe_string($message, 'event');
            if ($event === 'subscribe') {
                $this->handle_subscription_status($client, $message);
                return;
            }
            $channel = $this->safe_string($message, 'channel', '');
            $channelParts = explode('.', $channel);
            $channelType = $this->safe_value($channelParts, 1);
            $v4Methods = array(
                'usertrades' => array($this, 'handle_my_trades'),
                'candlesticks' => array($this, 'handle_ohlcv'),
                'orders' => array($this, 'handle_order'),
                'tickers' => array($this, 'handle_ticker'),
                'order_book_update' => array($this, 'handle_order_book'),
            );
            $method = $this->safe_value($v4Methods, $channelType);
        }
        if ($method !== null) {
            $method($client, $message);
        }
    }

    public function get_uniform_type($type) {
        $uniformType = 'spot';
        if ($type === 'future' || $type === 'swap') {
            $uniformType = 'futures';
        } else if ($type === 'option') {
            $uniformType = 'options';
        }
        return $uniformType;
    }

    public function get_url_by_market_type($type, $isInverse = false) {
        if ($type === 'spot') {
            $spotUrl = $this->urls['api']['spot'];
            if ($spotUrl === null) {
                throw new NotSupported($this->id . ' does not have a testnet for the ' . $type . ' market $type->');
            }
            return $spotUrl;
        }
        if ($type === 'swap') {
            $baseUrl = $this->urls['api']['swap'];
            return $isInverse ? $baseUrl['btc'] : $baseUrl['usdt'];
        }
        if ($type === 'future') {
            $baseUrl = $this->urls['api']['future'];
            return $isInverse ? $baseUrl['btc'] : $baseUrl['usdt'];
        }
        if ($type === 'option') {
            return $this->urls['api']['option'];
        }
    }

    public function subscribe_public($url, $channel, $messageHash, $payload, $subscriptionParams = array ()) {
        $time = $this->seconds();
        $request = array(
            'id' => $time,
            'time' => $time,
            'channel' => $channel,
            'event' => 'subscribe',
            'payload' => $payload,
        );
        $subscription = array(
            'id' => $time,
            'messageHash' => $messageHash,
        );
        $subscription = array_merge($subscription, $subscriptionParams);
        return yield $this->watch($url, $messageHash, $request, $messageHash, $subscription);
    }

    public function subscribe_private($url, $channel, $messageHash, $payload, $requiresUid = false) {
        $this->check_required_credentials();
        // uid is required for some subscriptions only so it's not a part of required credentials
        if ($requiresUid) {
            if ($this->uid === null || strlen($this->uid) === 0) {
                throw new ArgumentsRequired($this->id . ' requires uid to subscribe');
            }
            $idArray = [$this->uid];
            $payload = $this->array_concat($idArray, $payload);
        }
        $time = $this->seconds();
        $event = 'subscribe';
        $signaturePayload = 'channel=' . $channel . '&' . 'event=' . $event . '&' . 'time=' . (string) $time;
        $signature = $this->hmac($this->encode($signaturePayload), $this->encode($this->secret), 'sha512', 'hex');
        $auth = array(
            'method' => 'api_key',
            'KEY' => $this->apiKey,
            'SIGN' => $signature,
        );
        $requestId = $this->nonce();
        $request = array(
            'id' => $requestId,
            'time' => $time,
            'channel' => $channel,
            'event' => 'subscribe',
            'payload' => $payload,
            'auth' => $auth,
        );
        $subscription = array(
            'id' => $requestId,
            'messageHash' => $messageHash,
        );
        return yield $this->watch($url, $messageHash, $request, $messageHash, $subscription);
    }
}
