<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception as Exception; // a common import

class poloniex extends Exchange {

    public function describe () {
        return array_replace_recursive (parent::describe (), array (
            'has' => array (
                'fetchWsTicker' => true,
                'fetchWsOrderBook' => true,
            ),
            'urls' => array (
                'api' => array (
                    'wss' => 'wss://api2.poloniex.com/',
                ),
            ),
        ));
    }

    public function get_ws_message_hash ($client, $response) {
        $channelId = (string) $response[0];
        $length = is_array ($response) ? count ($response) : 0;
        if ($length <= 2) {
            return;
        }
        if ($channelId === '1002') {
            return $channelId . (string) $response[2][0];
        } else {
            return $channelId;
        }
    }

    public function handle_ws_ticker ($response) {
        $data = $response[2];
        $market = $this->safe_value($this->options['marketsByNumericId'], (string) $data[0]);
        $symbol = $this->safe_string($market, 'symbol');
        return array (
            'info' => $response,
            'symbol' => $symbol,
            'last' => floatval ($data[1]),
            'ask' => floatval ($data[2]),
            'bid' => floatval ($data[3]),
            'change' => floatval ($data[4]),
            'baseVolume' => floatval ($data[5]),
            'quoteVolume' => floatval ($data[6]),
            'active' => $data[7] ? false : true,
            'high' => floatval ($data[8]),
            'low' => floatval ($data[9]),
        );
    }

    public function fetch_ws_ticker ($symbol) {
        $this->load_markets();
        $this->markets_by_numeric_id ();
        $market = $this->market ($symbol);
        $numericId = (string) $market['info']['id'];
        $url = $this->urls['api']['websocket']['public'];
        return $this->WsTickerMessage ($url, '1002' . $numericId, array (
            'command' => 'subscribe',
            'channel' => 1002,
        ));
    }

    public function markets_by_numeric_id () {
        if ($this->options['marketsByNumericId'] === null) {
            $keys = is_array($this->markets) ? array_keys($this->markets) : array();
            $this->options['marketsByNumericId'] = array();
            for ($i = 0; $i < count ($keys); $i++) {
                $key = $keys[$i];
                $market = $this->markets[$key];
                $numericId = (string) $market['info']['id'];
                $this->options['marketsByNumericId'][$numericId] = $market;
            }
        }
    }

    public function fetch_ws_order_book ($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $this->markets_by_numeric_id ();
        $market = $this->market ($symbol);
        $numericId = (string) $market['info']['id'];
        $url = $this->urls['api']['websocket']['public'];
        return $this->WsOrderBookMessage ($url, $numericId, array (
            'command' => 'subscribe',
            'channel' => $numericId,
        ));
    }

    public function handle_ws_order_book ($orderBook) {
        // TODO => handle incremental trades too
        $data = $orderBook[2];
        $deltas = array();
        for ($i = 0; $i < count ($data); $i++) {
            $delta = $data[$i];
            if ($delta[0] === 'i') {
                $rawBook = $delta[1]['orderBook'];
                $bids = $rawBook[1];
                $asks = $rawBook[0];
                $delta = array (
                    'bids' => $this->parse_bid_ask($bids),
                    'asks' => $this->parse_bid_ask($asks),
                    'nonce' => null,
                    'timestamp' => null,
                    'datetime' => null,
                );
                $deltas[] = $delta;
            } else if ($delta[0] === 'o') {
                $price = floatval ($delta[2]);
                $amount = floatval ($delta[3]);
                $operation = $amount === 0 ? 'delete' : 'add';
                $side = $delta[1] ? 'bids' : 'asks';
                $delta = [null, $operation, $side, $price, $amount];
                $deltas[] = $delta;
            }
        }
        $market = $this->safe_value($this->options['marketsByNumericId'], (string) $orderBook[0]);
        $symbol = $this->safe_string($market, 'symbol');
        if (!(is_array($this->orderBooks) && array_key_exists($symbol, $this->orderBooks))) {
            $this->orderBooks[$symbol] = new IncrementalOrderBook (array_shift($deltas));
        }
        $incrementalBook = $this->orderBooks[$symbol];
        $incrementalBook->update ($deltas);
        $incrementalBook->orderBook['nonce'] = $orderBook[1];
        return $incrementalBook->orderBook;
    }

    public function parse_bid_ask ($bidasks) {
        $prices = is_array($bidasks) ? array_keys($bidasks) : array();
        $result = array();
        for ($i = 0; $i < count ($prices); $i++) {
            $price = $prices[$i];
            $amount = $bidasks[$price];
            $result[] = [floatval ($price), floatval ($amount)];
        }
        return $result;
    }

    public function handle_ws_dropped ($client, $response, $messageHash) {
        if ($messageHash !== null && intval ($messageHash) < 1000) {
            $this->handle_ws_order_book ($response);
        }
    }
}
