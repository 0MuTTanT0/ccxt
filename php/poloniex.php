<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\WebSocketTrait; // websocket functionality

class poloniex extends \ccxt\poloniex {

    use WebSocketTrait;

    public function describe () {
        return array_replace_recursive (parent::describe (), array (
            'has' => array (
                'fetchWsTicker' => true,
                'fetchWsOrderBook' => true,
            ),
            'urls' => array (
                'api' => array (
                    'ws' => 'wss://api2.poloniex.com/',
                ),
            ),
        ));
    }

    public function get_ws_message_hash ($client, $response) {
        $channelId = (string) $response[0];
        $length = is_array ($response) ? count ($response) : 0;
        if ($length <= 2) {
            return;
        }
        if ($channelId === '1002') {
            return $channelId . (string) $response[2][0];
        } else {
            return $channelId;
        }
    }

    public function handle_ws_ticker ($response) {
        $data = $response[2];
        $market = $this->safe_value($this->options['marketsByNumericId'], (string) $data[0]);
        $symbol = $this->safe_string($market, 'symbol');
        return array (
            'info' => $response,
            'symbol' => $symbol,
            'last' => floatval ($data[1]),
            'ask' => floatval ($data[2]),
            'bid' => floatval ($data[3]),
            'change' => floatval ($data[4]),
            'baseVolume' => floatval ($data[5]),
            'quoteVolume' => floatval ($data[6]),
            'active' => $data[7] ? false : true,
            'high' => floatval ($data[8]),
            'low' => floatval ($data[9]),
        );
    }

    public function fetch_ws_ticker ($symbol) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $numericId = (string) $market['info']['id'];
        $url = $this->urls['api']['websocket']['public'];
        return $this->WsTickerMessage ($url, '1002' . $numericId, array (
            'command' => 'subscribe',
            'channel' => 1002,
        ));
    }

    public function load_markets ($reload = false, $params = array ()) {
        $markets = parent::load_markets($reload, $params);
        $marketsByNumericId = $this->safe_value($this->options, 'marketsByNumericId');
        if (($marketsByNumericId === null) || $reload) {
            $marketsByNumericId = array();
            for ($i = 0; $i < count ($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $market = $this->markets[$symbol];
                $numericId = $this->safe_string($market, 'numericId');
                $marketsByNumericId[$numericId] = $market;
            }
            $this->options['marketsByNumericId'] = $marketsByNumericId;
        }
        return $markets;
    }

    public function fetch_ws_order_book ($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $numericId = $this->safe_string($market, 'numericId');
        $url = $this->urls['api']['ws'];
        $orderbook = $this->sendWsMessage ($this->handleWsOrderBook, $url, $numericId, array (
            'command' => 'subscribe',
            'channel' => $numericId,
        ));
        return $orderbook->limit ($limit)
        // // add $limit method
        // return array_merge ($orderbook, array (
        //     'bids' => mb_substr($orderbook['bids'], 0, $limit - 0),
        //     'asks' => mb_substr($orderbook['asks'], 0, $limit - 0),
        // ));
        // return $this->WsOrderBookMessage ($url, $numericId, array (
        //     'command' => 'subscribe',
        //     'channel' => $numericId,
        // ));
    }

    public function handle_ws_order_book ($message) {
        //
        // first response
        //
        //     [
        //         14, // channelId === $market['numericId']
        //         8767, // $nonce
        //         array (
        //             array (
        //                 "$i", // initial $snapshot
        //                 {
        //                     "currencyPair" => "BTC_BTS",
        //                     "orderBook" => array (
        //                         array ( // $asks
        //                             "0.00001853" => "2537.5637", // $price, size
        //                             "0.00001854" => "1567238.172367"
        //                         ),
        //                         { // $bids
        //                             "0.00001841" => "3645.3647",
        //                             "0.00001840" => "1637.3647"
        //                         }
        //                     )
        //                 }
        //             )
        //         )
        //     ]
        //
        // subsequent updates
        //
        //     array (
        //         14,
        //         8768,
        //         array (
        //             array ( "o", 1, "0.00001823", "5534.6474" ), // $orderbook $delta, $bids, $price, size
        //             array ( "o", 0, "0.00001824", "6575.464" ), // $orderbook $delta, $asks, $price, size
        //             array ( "t", "42706057", 1, "0.05567134", "0.00181421", 1522877119 ) // trade, id, sell, $price, size, timestamp
        //         )
        //     )
        //
        // TODO => handle incremental trades too
        // var_dump ('were here again', $orderbook)
        // exit ()
        $marketId = (string) $message[0];
        $nonce = $message[1];
        $data = $message[2];
        $market = $this->safe_value($this->options['marketsByNumericId'], $marketId);
        $symbol = $this->safe_string($market, 'symbol');
        $deltas = array();
        for ($i = 0; $i < count ($data); $i++) {
            $delta = $data[$i];
            if ($delta[0] === 'i') {
                $snapshot = $this->safe_value($delta[1], 'orderBook', array());
                $sides = array ( 'asks', 'bids' );
                $orderbook = $this->orderbook ($symbol);
                for ($j = 0; $j < count ($snapshot); $j++) {
                    $orders = $snapshot[$j];
                    $side = $sides[$j];
                    $prices = is_array($orders) ? array_keys($orders) : array();
                    $bookside = $orderbook[$side];
                    for ($k = 0; $k < count ($prices); $k++) {
                        $price = $prices[$k];
                        $amount = floatval ($orders[$price]);
                        $bookside->store ($price, $amount);
                    }
                    $bookside->reset ($bookside->index);
                }
                $orderbook['nonce'] = $nonce;
                return $orderbook;
                var_dump ($orderbook);
                exit ();
                // $asks = $snapshot[0];
                // $bids = $snapshot[1];
                // $prices = is_array($asks) ? array_keys($asks) : array();
                // for ($j = 0; $j < count ($prices); $j++) {
                //     $price = $prices[$i];
                //     $amount = floatval ($asks[$price]);
                //     $orderbook['asks'].store (array ( $price, $amount ));
                // }
                // for ($j = 0; $j < count ($asks); $j++) {
                //     $orderbook->asks.store ();
                // }
                // $this->orderbooks[$symbol] = new IncrementalOrderBook (array (
                //     'bids' => $this->parse_bid_ask($bids),
                //     'asks' => $this->parse_bid_ask($asks),
                //     'nonce' => $nonce,
                //     'timestamp' => null,
                //     'datetime' => null,
                // ));
            } else if ($delta[0] === 'o') {
                $price = floatval ($delta[2]);
                $amount = floatval ($delta[3]);
                $operation = ($amount === 0) ? 'delete' : 'add';
                $side = $delta[1] ? 'bids' : 'asks';
                $delta = [null, $operation, $side, $price, $amount];
                $deltas[] = $delta;
            }
        }
        // if (!(is_array($this->orderBooks) && array_key_exists($symbol, $this->orderBooks))) {
        //
        // }
        // $incrementalBook = $this->orderBooks[$symbol];
        // $incrementalBook->update ($deltas);
        // $incrementalBook->orderBook['nonce'] = $orderbook[1];
        // return $incrementalBook->orderBook;
    }

    public function parse_bid_ask ($bidasks) {
        $prices = is_array($bidasks) ? array_keys($bidasks) : array();
        $result = array();
        for ($i = 0; $i < count ($prices); $i++) {
            $price = $prices[$i];
            $amount = $bidasks[$price];
            $result[] = array ( floatval ($price), floatval ($amount) );
        }
        return $result;
    }

    public function handle_ws_dropped ($client, $message, $messageHash) {
        var_dump ('??');
        if ($messageHash !== null && intval ($messageHash) < 1000) {
            $this->handle_ws_order_book ($message);
        }
    }
}
