<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\AuthenticationError;

class coinflex extends \ccxt\async\coinflex {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://v2api.coinflex.com/v2/websocket',
                ),
                'test' => array(
                    'ws' => 'wss://v2stgapi.coinflex.com/v2/websocket',
                ),
            ),
            'options' => array(
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        '20000' => '\\ccxt\\AuthenticationError', // array( event => 'login', success => false,  message => 'Signature is invalid', code => '20000', timestamp => '1652709878447' )
                        '710003' => '\\ccxt\\BadRequest', // array( event => 'placeorder', submitted => false, tag => '1652714023869', message => 'FAILED sanity bound check as price (14000) > upper bound (13260)', code => '710003', timestamp => '1652714024078' )
                        '710006' => '\\ccxt\\InsufficientFunds', // array( event => 'placeorder', submitted => false, tag => '1652788574125', message => 'FAILED balance check as balance (46.8941381080) < value (3152.800)', code => '710006', timestamp => '1652788574376' )
                    ),
                ),
            ),
        ));
    }

    public function watch_ticker($symbol, $params = array ()) {
        $channel = 'ticker';
        yield $this->load_markets();
        $market = $this->market($symbol);
        $messageHash = $channel . ':' . $market['id'];
        return yield $this->watch_public($messageHash, $messageHash, $params);
    }

    public function handle_ticker($client, $message) {
        //
        //     {
        //         table => 'ticker',
        //         $data => array(
        //           {
        //             last => '29586',
        //             open24h => '29718',
        //             high24h => '31390',
        //             low24h => '29299',
        //             volume24h => '30861108.9365753390',
        //             currencyVolume24h => '1017.773',
        //             openInterest => '0',
        //             marketCode => 'BTC-USD',
        //             timestamp => '1652693831002',
        //             lastQty => '0.001',
        //             markPrice => '29586',
        //             lastMarkPrice => '29601'
        //           }
        //         )
        //     }
        //
        $topic = $this->safe_string($message, 'table');
        $tickers = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($tickers); $i++) {
            $data = $tickers[$i];
            $marketId = $this->safe_string($data, 'marketCode');
            $market = $this->safe_market($marketId, null);
            $messageHash = $topic . ':' . $marketId;
            $ticker = $this->parse_ws_ticker($data, $market);
            $symbol = $ticker['symbol'];
            $this->tickers[$symbol] = $ticker;
            $client->resolve ($ticker, $messageHash);
        }
        return $message;
    }

    public function parse_ws_ticker($ticker, $market = null) {
        //
        //    {
        //        last => '29586',
        //        open24h => '29718',
        //        high24h => '31390',
        //        low24h => '29299',
        //        volume24h => '30861108.9365753390',
        //        currencyVolume24h => '1017.773',
        //        openInterest => '0',
        //        marketCode => 'BTC-USD',
        //        $timestamp => '1652693831002',
        //        lastQty => '0.001',
        //        markPrice => '29586',
        //        lastMarkPrice => '29601'
        //    }
        //
        $timestamp = $this->safe_integer($ticker, 'timestamp');
        $marketId = $this->safe_string($ticker, 'marketCode');
        $market = $this->safe_market($marketId, $market);
        $close = $this->safe_string($ticker, 'last');
        $open = $this->safe_string($ticker, 'open24h');
        $high = $this->safe_string($ticker, 'high24h');
        $low = $this->safe_string($ticker, 'low24h');
        $baseVolume = $this->safe_string($ticker, 'currencyVolume24h');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $channel = 'candles';
        yield $this->load_markets();
        $market = $this->market($symbol);
        $symbol = $market['symbol'];
        $interval = $this->timeframes[$timeframe];
        $messageHash = $channel . $interval . ':' . $market['id'];
        $ohlcv = yield $this->watch_public($messageHash, $messageHash, $params);
        if ($this->newUpdates) {
            $limit = $ohlcv->getLimit ($symbol, $limit);
        }
        return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
    }

    public function handle_ohlcv($client, $message) {
        //
        //     "table":"candles60s",
        //     "data":array(
        //        {
        //           "candle":array(
        //              "1652695200000",
        //              "29598",
        //              "29598",
        //              "29597.585628",
        //              "29597.585628",
        //              "1589597.531322996",
        //              "53.707"
        //           ),
        //           "marketCode":"BTC-USD"
        //        }
        //     )
        //  }
        //
        $topic = $this->safe_string($message, 'table');
        $interval = str_replace('candles', '', $topic);
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $candles = $this->safe_value($entry, 'candle', array());
            $marketId = $this->safe_string($entry, 'marketCode');
            $market = $this->safe_market($marketId, null);
            $messageHash = $topic . ':' . $marketId;
            $symbol = $market['symbol'];
            $timeframe = $this->find_timeframe($interval);
            $ohlcvs = $this->parse_ws_ohlcv($candles, $market);
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol][$timeframe] = $stored;
            }
            $stored->append ($ohlcvs);
            $client->resolve ($stored, $messageHash);
        }
    }

    public function parse_ws_ohlcv($ohlcv, $market = null) {
        //
        //  array(
        //     "1652695200000",
        //     "29598",
        //     "29598",
        //     "29597.585628",
        //     "29597.585628",
        //     "1589597.531322996",
        //     "53.707"
        //  )
        //
        return array(
            $this->safe_number($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 6),
        );
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        $channel = 'depth';
        yield $this->load_markets();
        $market = $this->market($symbol);
        $messageHash = $channel . ':' . $market['id'];
        $orderbook = yield $this->watch_public($messageHash, $messageHash, $params);
        return $orderbook->limit ($limit);
    }

    public function handle_order_book($client, $message) {
        //
        // we get always the full $snapshot
        //
        // {
        //     "table":"depth",
        //     "data":array(
        //        {
        //           "instrumentId":"BTC-USD-SWAP-LIN",
        //           "seqNum":"1650424356029712528",
        //           "asks":array(
        //              [29878,0.303,0,0 ),
        //              [29880,0.004,0,0 ),
        //           ],
        //           "checksum":-1222631948,
        //           "bids":array(
        //              array( 29877, 0.047, 0, 0 ),
        //              array( 29872, 0.001, 0, 0 ),
        //           ),
        //           "timestamp":"1652708448921"
        //        }
        //     ],
        //     "action":"partial"
        //  }
        //
        $channel = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $marketId = $this->safe_string($entry, 'instrumentId');
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $timestamp = $this->safe_integer($entry, 'timestamp');
            $snapshot = $this->parse_order_book($entry, $symbol, $timestamp);
            $orderbook = null;
            if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
                $orderbook = $this->order_book($snapshot);
                $this->orderbooks[$symbol] = $orderbook;
            } else {
                $orderbook = $this->orderbooks[$symbol];
                $orderbook->reset ($snapshot);
            }
            $messageHash = $channel . ':' . $marketId;
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $channel = 'trade';
        yield $this->load_markets();
        $market = $this->market($symbol);
        $symbol = $market['symbol'];
        $messageHash = $channel . ':' . $market['id'];
        $trades = yield $this->watch_public($messageHash, $messageHash, $params);
        if ($this->newUpdates) {
            $limit = $trades->getLimit ($symbol, $limit);
        }
        return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
    }

    public function handle_trades($client, $message) {
        //
        //    {
        //        table => 'trade',
        //        $data => array(
        //          {
        //            side => 'BUY',
        //            quantity => '0.042',
        //            price => '30081.0',
        //            marketCode => 'BTC-USD-SWAP-LIN',
        //            tradeId => '304734619689878207',
        //            timestamp => '1652698566797'
        //          }
        //        )
        //    }
        //
        $topic = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        $tradesLimit = $this->safe_integer($this->options, 'tradesLimit', 1000);
        $marketIds = array();
        for ($i = 0; $i < count($data); $i++) {
            $trade = $data[$i];
            $marketId = $this->safe_string($trade, 'marketCode');
            $marketIds[$marketId] = true;
            $market = $this->safe_market($marketId, null);
            $symbol = $market['symbol'];
            $parsedTrade = $this->parse_ws_trade($trade, $market);
            $stored = $this->safe_value($this->trades, $symbol);
            if ($stored === null) {
                $stored = new ArrayCache ($tradesLimit);
                $this->trades[$symbol] = $stored;
            }
            $stored->append ($parsedTrade);
        }
        $marketIdsArray = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($marketIdsArray); $i++) {
            $marketId = $marketIdsArray[$i];
            $messageHash = $topic . ':' . $marketId;
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $stored = $this->safe_value($this->trades, $symbol);
            $client->resolve ($stored, $messageHash);
        }
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        //   {
        //       $side => 'BUY',
        //       quantity => '0.042',
        //       $price => '30081.0',
        //       marketCode => 'BTC-USD-SWAP-LIN',
        //       tradeId => '304734619689878207',
        //       $timestamp => '1652698566797'
        //   }
        //
        $marketId = $this->safe_string($trade, 'marketCode');
        $market = $this->safe_market($marketId, $market);
        $id = $this->safe_string($trade, 'tradeId');
        $timestamp = $this->safe_integer($trade, 'timestamp');
        $side = $this->safe_string_lower($trade, 'side');
        $amount = $this->safe_string($trade, 'quantity');
        $price = $this->safe_string($trade, 'price');
        return $this->safe_trade(array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'order' => null,
            'type' => null,
            'takerOrMaker' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
            'info' => $trade,
        ), $market);
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $messageHash = 'order';
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash .= ':' . $market['id'];
        } else {
            $messageHash .= ':all';
        }
        $orders = yield $this->watch_private($messageHash, $messageHash, $params);
        if ($this->newUpdates) {
            $limit = $orders->getLimit ($symbol, $limit);
        }
        return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
    }

    public function handle_order($client, $message, $subscription = null) {
        //
        //
        //    {
        //        table => 'order',
        //        data => array(
        //          {
        //            accountId => '39422',
        //            clientOrderId => '1652712518830',
        //            orderId => '1002215627250',
        //            price => '40.0',
        //            quantity => '0.01',
        //            side => 'BUY',
        //            status => 'CANCELED_BY_USER',
        //            marketCode => 'LTC-USD',
        //            timeInForce => 'GTC',
        //            timestamp => '1652712536469',
        //            remainQuantity => '0.01',
        //            $notice => 'OrderClosed',
        //            orderType => 'LIMIT',
        //            isTriggered => 'false'
        //          }
        //        )
        //    }
        //
        //    {
        //      table => 'order',
        //      data => array(
        //        {
        //          accountId => '39422',
        //          clientOrderId => '1652713431643',
        //          orderId => '1002215706472',
        //          quantity => '0.001',
        //          side => 'SELL',
        //          status => 'FILLED',
        //          marketCode => 'BTC-USD-SWAP-LIN',
        //          timestamp => '1652713431854',
        //          matchId => '304734619690202846', // trade field
        //          matchPrice => '29480.0', // trade field
        //          matchQuantity => '0.001', // trade field
        //          orderMatchType => 'TAKER', // trade field
        //          remainQuantity => '0.0',
        //          $notice => 'OrderMatched',
        //          orderType => 'MARKET',
        //          fees => '0.02358400',
        //          feeInstrumentId => 'USD',
        //          isTriggered => 'false'
        //        }
        //      )
        //    }
        //
        $channel = $this->safe_string($message, 'table');
        $rawOrders = $this->safe_value($message, 'data', array());
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $stored = $this->orders;
        $marketIds = array();
        for ($i = 0; $i < count($rawOrders); $i++) {
            $order = $rawOrders[$i];
            $notice = $this->safe_string($order, 'notice');
            if ($notice === 'OrderMatched') {
                // this means that the $order has the trade info built in so
                // it's a $order . trade update combined
                $tradeObject = array(
                    'matchId' => $this->safe_string($order, 'matchId'),
                    'matchPrice' => $this->safe_string($order, 'matchPrice'),
                    'matchQuantity' => $this->safe_string($order, 'matchQuantity'),
                    'orderMatchType' => $this->safe_string($order, 'orderMatchType'),
                    'matchTimestamp' => $this->safe_string($order, 'timestamp'),
                    'orderType' => $this->safe_string($order, 'orderType'),
                    'fees' => $this->safe_string($order, 'fees'),
                    'feeInstrumentId' => $this->safe_string($order, 'feeInstrumentId'),
                    'side' => $this->safe_string($order, 'side'),
                    'orderId' => $this->safe_string($order, 'orderId'),
                    'marketCode' => $this->safe_string($order, 'marketCode'),
                );
                // we don't use the own $order object itself ($order['matchIds'] = $order)
                // because would cause a circular import error in json later on
                $order['matchIds'] = array( $tradeObject );
                $this->handle_my_trade($client, $tradeObject);
            }
            $parsed = $this->parse_order($order);
            $stored->append ($parsed);
            $symbol = $parsed['symbol'];
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $marketIds[$marketId] = true;
        }
        // non-$symbol specific
        $messageHash = $channel . ':all';
        $client->resolve ($this->orders, $messageHash);
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $marketId = $keys[$i];
            $messageHash = $channel . ':' . $marketId;
            $client->resolve ($this->orders, $messageHash);
        }
    }

    public function handle_my_trade($client, $message) {
        //
        //  {
        //          accountId => '39422',
        //          orderId => '1002215706472',
        //          side => 'SELL',
        //          marketCode => 'BTC-USD-SWAP-LIN',
        //          matchTimestamp => '1652713431854',
        //          matchId => '304734619690202846',
        //          matchPrice => '29480.0',
        //          matchQuantity => '0.001',
        //          orderMatchType => 'TAKER',
        //          orderType => 'MARKET',
        //          fees => '0.02358400',
        //          feeInstrumentId => 'USD',
        //   }
        //
        $marketId = $this->safe_string($message, 'marketCode');
        $market = $this->safe_market($marketId, null);
        $trades = $this->myTrades;
        if ($trades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $trades = new ArrayCacheBySymbolById ($limit);
        }
        $parsed = $this->parse_trade($message, $market);
        // add missing field
        $parsed['type'] = $this->safe_string_lower($message, 'orderType');
        $trades->append ($parsed);
        $channel = 'usertrade';
        $messageHash = $channel . ':' . $market['id'];
        $client->resolve ($trades, $messageHash);
        $genericHash = $channel . ':all';
        $client->resolve ($trades, $genericHash);
    }

    public function watch_balance($params = array ()) {
        $messageHash = 'balance:all';
        return yield $this->watch_private($messageHash, $messageHash, $params);
    }

    public function handle_balance($client, $message) {
        //
        //    {
        //        table => 'balance',
        //        accountId => '39422',
        //        timestamp => '1652710563235',
        //        tradeType => 'LINEAR',
        //        $data => array(
        //          array(
        //            total => '47.7114057900',
        //            reserved => '6.00',
        //            instrumentId => 'USD',
        //            available => '41.7114057900',
        //            quantityLastUpdated => '1652188203911'
        //          ),
        //          {
        //            total => '0.98',
        //            reserved => '0',
        //            instrumentId => 'DOGE',
        //            available => '0.98',
        //            quantityLastUpdated => '1651655519741'
        //          }
        //        )
        //    }
        //
        $channel = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $balance = $data[$i];
            $currencyId = $this->safe_string($balance, 'instrumentId');
            $code = $this->safe_currency_code($currencyId);
            $account = (is_array($this->balance) && array_key_exists($code, $this->balance)) ? $this->balance[$code] : $this->account();
            $account['total'] = $this->safe_string($balance, 'total');
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'reserved');
            $this->balance[$code] = $account;
        }
        $this->balance = $this->safe_balance($this->balance);
        $messageHash = $channel . ':all';
        $client->resolve ($this->balance, $messageHash);
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $subscriptionHash = 'order';
        $messageHash = 'usertrade';
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $subscriptionHash .= ':' . $market['id'];
            $messageHash .= ':' . $market['id'];
        } else {
            $subscriptionHash .= ':all';
            $messageHash .= ':all';
        }
        $trades = yield $this->watch_private($subscriptionHash, $messageHash, $params);
        if ($this->newUpdates) {
            $limit = $trades->getLimit ($symbol, $limit);
        }
        return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
    }

    public function watch_public($subscriptionHash, $messageHash, $params = array ()) {
        $url = $this->urls['api']['ws'];
        $id = $this->nonce();
        $request = array(
            'op' => 'subscribe',
            'tag' => $id,
            'args' => array( $subscriptionHash ),
        );
        $message = array_merge($request, $params);
        return yield $this->watch($url, $messageHash, $message, $subscriptionHash);
    }

    public function watch_private($subscriptionHash, $messageHash, $params = array ()) {
        yield $this->authenticate();
        return yield $this->watch_public($subscriptionHash, $messageHash, $params);
    }

    public function authenticate($params = array ()) {
        $this->check_required_credentials();
        $url = $this->urls['api']['ws'];
        $messageHash = 'login';
        $client = $this->client($url);
        $future = $this->safe_value($client->subscriptions, $messageHash);
        if ($future === null) {
            $future = $client->future ('authenticated');
            $timestamp = (string) $this->milliseconds();
            $method = 'GET';
            $path = '/auth/self/verify';
            $auth = $timestamp . $method . $path;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'base64');
            $request = array(
                'op' => $messageHash,
                'data' => array(
                    'apiKey' => $this->apiKey,
                    'timestamp' => $timestamp,
                    'signature' => $signature,
                ),
            );
            $this->spawn(array($this, 'watch'), $url, $messageHash, $request, $messageHash, $future);
        }
        return yield $future;
    }

    public function handle_error_message($client, $message) {
        //
        //    {
        //        event => 'login',
        //        $success => false,
        //        $message => 'Signature is invalid',
        //        code => '20000',
        //        timestamp => '1652709878447'
        //    }
        //
        //    {
        //        event => 'placeorder',
        //        submitted => false,
        //        tag => '1652714023869',
        //        $message => 'FAILED sanity bound check as price (14000) >  upper bound (13260)',
        //        code => '710003',
        //        timestamp => '1652714024078',
        //        data => {
        //          clientOrderId => '1652714023869',
        //          marketCode => 'BTC-USD-SWAP-LIN',
        //          side => 'BUY',
        //          orderType => 'STOP_LIMIT',
        //          quantity => '0.001',
        //          timeInForce => 'GTC',
        //          limitPrice => '14000',
        //          stopPrice => '13000',
        //          source => 0
        //        }
        //     }
        //
        $success = $this->safe_value($message, 'success');
        try {
            if (!$success) {
                $error = $this->safe_string($message, 'code');
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $error, $feedback);
            }
        } catch (Exception $e) {
            if ($e instanceof AuthenticationError) {
                $client->reject ($e, 'authenticated');
                $method = 'login';
                if (is_array($client->subscriptions) && array_key_exists($method, $client->subscriptions)) {
                    unset($client->subscriptions[$method]);
                }
                return false;
            }
        }
        return $message;
    }

    public function handle_message($client, $message) {
        //
        //   array( $event => 'Welcome', nonce => '253ae705', timestamp => '1652711966653' )
        //
        //   {
        //      success => true,
        //      tag => '1652712019244',
        //      $event => 'subscribe',
        //      channel => 'trade:BTC-USD',
        //      timestamp => '1652712020624'
        //   }
        //
        //   {
        //       $event => 'placeorder',
        //       submitted => true,
        //       tag => '1652714101465',
        //       timestamp => '1652714101676',
        //       data => {
        //         clientOrderId => '1652714101465',
        //         marketCode => 'BTC-USD-SWAP-LIN',
        //         side => 'BUY',
        //         orderType => 'STOP_LIMIT',
        //         quantity => '0.001',
        //         timeInForce => 'GTC',
        //         limitPrice => '15300',
        //         stopPrice => '15000',
        //         orderId => '1002215765848',
        //         source => 0
        //       }
        //   }
        //
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        $event = $this->safe_string($message, 'event');
        if ($event === 'login') {
            $this->handle_authenticate($client, $message);
            return;
        }
        $tables = array(
            'ticker' => array($this, 'handle_ticker'),
            'trade' => array($this, 'handle_trades'),
            'depth' => array($this, 'handle_order_book'),
            'order' => array($this, 'handle_order'),
            'balance' => array($this, 'handle_balance'),
        );
        $topic = $this->safe_string($message, 'table');
        // specific check because this $topic has the timeframe attached
        // so we would need to list all possibilities in the methods object
        if ($topic !== null && mb_strpos($topic, 'candles') !== false) {
            $this->handle_ohlcv($client, $message);
            return;
        }
        $method = $this->safe_value($tables, $topic);
        if ($method !== null) {
            $method($client, $message);
        }
    }

    public function handle_authenticate($client, $message) {
        //
        //  array( event => 'login', success => true, timestamp => '1652710009321' )
        //
        $client->resolve ($message, 'authenticated');
        return $message;
    }

    public function handle_pong($client, $message) {
        $client->lastPong = $this->milliseconds();
        return $message;
    }
}
