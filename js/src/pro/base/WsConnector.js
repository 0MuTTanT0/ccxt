// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

import { throttle, safeValue } from '../../base/functions.js';
import WsClient from './WsClient.js';
import { OrderBook, IndexedOrderBook, CountedOrderBook } from './OrderBook.js';
import { inflate64, inflate, gunzip } from './functions.js';
;
export default class WsConnector {
    constructor(options = {}) {
        this.newUpdates = true;
        this.options = {};
        this.log = undefined;
        this.ping = undefined;
        this.verbose = undefined;
        this.clients = {};
        // timeframes = undefined
        this.tokenBucket = undefined;
        this.handleMessage = undefined;
        this.streaming = undefined;
        this.getVerboseMode = undefined;
        this.getTokenBucket = undefined;
        this.getKeepAlive = undefined;
        this.getInflate = undefined;
        this.getGunzip = undefined;
        this.getEnableRateLimit = undefined;
        this.newUpdates = options.newUpdates || true;
        this.log = options.log || this.log;
        this.getVerboseMode = options.getVerboseMode;
        this.handleMessage = options.handleMessage || this.handleMessage;
        this.newUpdates = true;
        this.options = {};
        this.log = options.log;
        // this.streaming = (options as any).streaming; 
        this.ping = options.ping;
        this.getTokenBucket = options.getTokenBucket;
        this.getKeepAlive = options.getKeepAlive;
        this.getInflate = options.getInflate;
        this.getGunzip = options.getGunzip;
        this.getEnableRateLimit = options.getEnableRateLimit;
        this.clients = {};
    }
    inflate(data) {
        return inflate(data);
    }
    inflate64(data) {
        return inflate64(data);
    }
    gunzip(data) {
        return gunzip(data);
    }
    orderBook(snapshot = {}, depth = Number.MAX_SAFE_INTEGER) {
        return new OrderBook(snapshot, depth);
    }
    indexedOrderBook(snapshot = {}, depth = Number.MAX_SAFE_INTEGER) {
        return new IndexedOrderBook(snapshot, depth);
    }
    countedOrderBook(snapshot = {}, depth = Number.MAX_SAFE_INTEGER) {
        return new CountedOrderBook(snapshot, depth);
    }
    client(url) {
        this.clients = this.clients || {};
        if (!this.clients[url]) {
            const onMessage = this.handleMessage;
            const onError = this.onError.bind(this);
            const onClose = this.onClose.bind(this);
            const onConnected = this.onConnected.bind(this);
            // decide client type here: ws / signalr / socketio
            // const wsOptions = safeValue (this.options, 'ws', {});
            const options = {
                'ping': this.ping,
                'getVerboseMode': this.getVerboseMode,
                'throttle': throttle(this.getTokenBucket()),
                'log': this.log,
                'getKeepAlive': this.getKeepAlive,
                'getInflate': this.getInflate,
                'getGunzip': this.getGunzip,
                'getEnableRateLimit': this.getEnableRateLimit,
            };
            this.clients[url] = new WsClient(url, onMessage, onError, onClose, onConnected, options);
        }
        return this.clients[url];
    }
    watch(url, messageHash, message = undefined, subscribeHash = undefined, subscription = undefined) {
        //
        // Without comments the code of this method is short and easy:
        //
        //     const client = this.client (url)
        //     const backoffDelay = 0
        //     const future = client.future (messageHash)
        //     const connected = client.connect (backoffDelay)
        //     connected.then (() => {
        //         if (message && !client.subscriptions[subscribeHash]) {
        //             client.subscriptions[subscribeHash] = true
        //             client.send (message)
        //         }
        //     }).catch ((error) => {})
        //     return future
        //
        // The following is a longer version of this method with comments
        //
        const client = this.client(url);
        // todo: calculate the backoff using the clients cache
        const backoffDelay = 0;
        //
        //  watchOrderBook ---- future ----+---------------+----→ user
        //                                 |               |
        //                                 ↓               ↑
        //                                 |               |
        //                              connect ......→ resolve
        //                                 |               |
        //                                 ↓               ↑
        //                                 |               |
        //                             subscribe -----→ receive
        //
        const future = client.future(messageHash);
        // we intentionally do not use await here to avoid unhandled exceptions
        // the policy is to make sure that 100% of promises are resolved or rejected
        // either with a call to client.resolve or client.reject with
        //  a proper exception class instance
        const connected = client.connect(backoffDelay);
        // the following is executed only if the catch-clause does not
        // catch any connection-level exceptions from the client
        // (connection established successfully)
        connected.then(() => {
            if (!client.subscriptions[subscribeHash]) {
                client.subscriptions[subscribeHash] = subscription || true;
                const options = safeValue(this.options, 'ws');
                const cost = safeValue(options, 'cost', 1);
                if (message) {
                    if (this.getEnableRateLimit() && client.throttle) {
                        // add cost here |
                        //               |
                        //               V
                        client.throttle(cost).then(() => {
                            client.send(message);
                        }).catch((e) => { throw e; });
                    }
                    else {
                        client.send(message);
                    }
                }
            }
        });
        return future;
    }
    onConnected(client, message = undefined) {
        // for user hooks
        // console.log ('Connected to', client.url)
    }
    onError(client, error) {
        if ((client.url in this.clients) && (this.clients[client.url].error)) {
            delete this.clients[client.url];
        }
    }
    onClose(client, error) {
        if (client.error) {
            // connection closed due to an error, do nothing
        }
        else {
            // server disconnected a working connection
            if (this.clients[client.url]) {
                delete this.clients[client.url];
            }
        }
    }
    async close() {
        const clients = Object.values(this.clients || {});
        for (let i = 0; i < clients.length; i++) {
            const client = clients[i];
            delete this.clients[client.url];
            await client.close();
        }
    }
    formatScientificNotationFTX(n) {
        if (n === 0) {
            return '0e-00';
        }
        return n.toExponential().replace('e-', 'e-0');
    }
}
;
export { WsConnector, };
